#pragma once

#include "Core/Maths/Packing/PackingHelpers.h"

namespace Core {
//----------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------------------
float UByte0255_to_Float01(u8 value) {
    const float f = value / 255.0f;
    Assert(0 <= f && 1 >= f);
    return f;
}
//----------------------------------------------------------------------------
float UByte0255_to_FloatM11(u8 value) {
    const float f = (value - 127.0f) / 127.0f;
    Assert(-1 <= f && 1 >= f);
    return f;
}
//----------------------------------------------------------------------------
u8 Float01_to_UByte0255(float value) {
    Assert(0 <= value && 1 >= value);
    return static_cast<u8>(value * 255.0f);
}
//----------------------------------------------------------------------------
u8 FloatM11_to_UByte0255(float value) {
    Assert(-1 <= value && 1 >= value);
    return static_cast<u8>((value + 1) * 127.0f);
}
//----------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------------------
float UShort065535_to_Float01(u16 value) {
    const float f = value / 65535.0f;
    Assert(0 <= f && 1 >= f);
    return f;
}
//----------------------------------------------------------------------------
float UShort065535_to_FloatM11(u16 value) {
    const float f = (value - 32767.0f) / 32767.0f;
    Assert(-1 <= f && 1 >= f);
    return f;
}
//----------------------------------------------------------------------------
u16 Float01_to_UShort065535(float value) {
    Assert(0 <= value && 1 >= value);
    return static_cast<u16>(value * 65535.0f);
}
//----------------------------------------------------------------------------
u16 FloatM11_to_UShort065535(float value) {
    Assert(-1 <= value && 1 >= value);
    return static_cast<u16>((value + 1) * 32767.0f);
}
//----------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------------------
float UWord_to_Float01(u32 value) {
    const float f = value / static_cast<float>(UINT32_MAX);
    Assert(0 <= f && 1 >= f);
    return f;
}
//----------------------------------------------------------------------------
float UWord_to_FloatM11(u32 value) {
    const float f = (value - static_cast<float>(UINT32_MAX >> 1)) / static_cast<float>(UINT32_MAX >> 1);
    Assert(-1 <= f && 1 >= f);
    return f;
}
//----------------------------------------------------------------------------
u32 Float01_to_UWord(float value) {
    Assert(0 <= value && 1 >= value);
    return static_cast<u16>(value * static_cast<float>(UINT32_MAX));
}
//----------------------------------------------------------------------------
u32 FloatM11_to_UWord(float value) {
    Assert(-1 <= value && 1 >= value);
    return static_cast<u16>((value + 1) * static_cast<float>(UINT32_MAX >> 1));
}
//----------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------------------
void HalfFloat::Pack(float value) {
    Assert(IsConvertible(value));
    _data = FP32_to_FP16(value);
}
//----------------------------------------------------------------------------
float HalfFloat::Unpack() const {
    const float f = FP16_to_FP32(_data);
    Assert(std::isfinite(f));
    return f;
}
//----------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------------------
} //!namespace Core
