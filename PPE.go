package main

import (
	. "build"
	. "build/compile"
	"build/utils"
	. "build/utils"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
)

var CorePublicDir = UFS.Source.Folder("Runtime", "Core", "Public")
var NatvisFile = UFS.Extras.Folder("Debug").File("PPE.natvis")

type UsageType string

const (
	USAGE_RUNTIME   UsageType = "Runtime"
	USAGE_SHIPPING  UsageType = "Shipping"
	USAGE_TOOLS     UsageType = "Tools"
	USAGE_DEVELOPER UsageType = "Developer"
)

func UsageTypes() []UsageType {
	return []UsageType{
		USAGE_RUNTIME,
		USAGE_SHIPPING,
		USAGE_TOOLS,
		USAGE_DEVELOPER,
	}
}

/***************************************
 * Build Version Header
 ***************************************/

var BuildVersionHeaderVersion = "BuildVersionHeader-1.2.0"

type BuildVersionHeaderGenerator struct {
	Version string
}

func (x *BuildVersionHeaderGenerator) Serialize(ar Archive) {
	ar.String(&x.Version)
}
func (x BuildVersionHeaderGenerator) CreateGenerated(unit *Unit, output Filename) Generated {
	return &BuildVersionGeneratedHeader{
		ModuleDir: unit.ModuleDir,
		Version:   x.Version,
	}
}

type BuildVersionGeneratedHeader struct {
	ModuleDir Directory
	Version   string
}

func (x *BuildVersionGeneratedHeader) Serialize(ar Archive) {
	ar.Serializable(&x.ModuleDir)
	ar.String(&x.Version)
}
func (x BuildVersionGeneratedHeader) Generate(bc BuildContext, generated *BuildGenerated, dst io.Writer) error {
	sourceControl, err := BuildSourceControlStatus(x.ModuleDir).Need(bc)
	if err != nil {
		return err
	}

	fmt.Fprintln(dst, "#pragma once")
	fmt.Fprintf(dst, "// Build version generated by %s - %s\n", PROCESS_INFO, x.Version)
	fmt.Fprintln(dst, "#include \"Core_fwd.h\"")
	fmt.Fprintln(dst, "namespace PPE::Generated {")
	fmt.Fprintf(dst, "constexpr const char BuildBranch[] = %q;\n", sourceControl.Branch)
	fmt.Fprintf(dst, "constexpr const char BuildRevision[] = %q;\n", sourceControl.Revision)
	fmt.Fprintf(dst, "constexpr const i64  BuildTimestamp = %sll;\n", strconv.FormatInt(sourceControl.Timestamp.Unix(), 10))
	fmt.Fprintln(dst, "} //!namespace PPE::Generated")
	return nil
}

/***************************************
 * Build Modules Header
 ***************************************/

var BuildModulesHeaderVersion = "BuildModulesHeader-1.1.0"

type BuildModulesHeaderGenerator struct {
	Version string
}

func (x *BuildModulesHeaderGenerator) Serialize(ar Archive) {
	ar.String(&x.Version)
}
func (x BuildModulesHeaderGenerator) CreateGenerated(unit *Unit, output Filename) Generated {
	return &BuildModulesGeneratedHeader{
		Version:             x.Version,
		Target:              unit.Target,
		LinkDependencies:    unit.LinkDependencies,
		RuntimeDependencies: unit.RuntimeDependencies,
		ShouldExportInfo:    unit.Payload != PAYLOAD_EXECUTABLE,
	}
}

type BuildModulesGeneratedHeader struct {
	Version             string
	Target              TargetAlias
	PayloadFile         Filename
	LinkDependencies    TargetAliases
	RuntimeDependencies TargetAliases
	ShouldExportInfo    bool
}

func (x *BuildModulesGeneratedHeader) Serialize(ar Archive) {
	ar.String(&x.Version)
	ar.Serializable(&x.Target)
	ar.Serializable(&x.PayloadFile)
	SerializeSlice(ar, x.LinkDependencies.Ref())
	SerializeSlice(ar, x.RuntimeDependencies.Ref())
	ar.Bool(&x.ShouldExportInfo)
}
func (x BuildModulesGeneratedHeader) Generate(bc BuildContext, generated *BuildGenerated, dst io.Writer) error {
	fmt.Fprintln(dst, "#pragma once")
	fmt.Fprintln(dst, "// Build modules generated by "+PROCESS_INFO.String()+" - "+x.Version)
	fmt.Fprintln(dst, "#include \"Core_fwd.h\"")
	fmt.Fprintln(dst, "#include \"IO/StringView.h\"")
	fmt.Fprintln(dst, "#include \"Modular/ModuleRegistration.h\"")
	fmt.Fprintln(dst, "#include <array>")
	if x.ShouldExportInfo {
		fmt.Fprintln(dst, "// DLL exports for current module:")
		fmt.Fprintln(dst, "extern \"C\" DLL_EXPORT const void* "+x.getModuleStaticInfo(x.Target)+"() {")
		fmt.Fprintln(dst, "    return (&::PPE::F"+x.getModuleClass(x.Target)+"::StaticInfo);")
		fmt.Fprintln(dst, "}")
	}
	fmt.Fprintln(dst, "// DLL imports for current module:")
	for _, it := range x.LinkDependencies {
		fmt.Fprintln(dst, "#include \""+x.getModuleClass(it)+".h\"")
		fmt.Fprintln(dst, "extern \"C\" DLL_IMPORT const void* "+x.getModuleStaticInfo(it)+"();")
	}
	fmt.Fprintln(dst, "namespace PPE::Generated {")
	fmt.Fprintln(dst, "// register/unregister for static modules:")
	fmt.Fprintln(dst, "inline void RegisterStaticModules() NOEXCEPT {")
	if len(x.LinkDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleStaticRegistration::Get();")
		for _, it := range x.LinkDependencies {
			fmt.Fprintln(dst, "    registry.RegisterAnchor(&"+x.getModuleStaticInfo(it)+");")
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "inline void UnregisterStaticModules() NOEXCEPT {")
	if len(x.LinkDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleStaticRegistration::Get();")
		for _, it := range x.LinkDependencies {
			fmt.Fprintln(dst, "    registry.UnregisterAnchor(&"+x.getModuleStaticInfo(it)+");")
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "inline void RegisterDynamicModules() NOEXCEPT {")
	if len(x.RuntimeDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleDynamicRegistration::Get();")
		for _, it := range x.RuntimeDependencies {
			fmt.Fprintf(dst, "    registry.RegisterLibrary(\"%s\", \"%s\", L\"%s\");\n",
				it.ModuleAlias,
				x.getModuleStaticInfo(it),
				x.PayloadFile)
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "inline void UnregisterDynamicModules() NOEXCEPT {")
	if len(x.RuntimeDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleDynamicRegistration::Get();")
		for _, it := range x.RuntimeDependencies {
			fmt.Fprintf(dst, "    registry.UnregisterLibrary(\"%s\");\n", it.ModuleAlias)
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "// list module dependencies by name:")
	fmt.Fprintf(dst, "constexpr std::array<FStringView, %d> DependencyList{\n",
		len(x.LinkDependencies)+len(x.RuntimeDependencies))
	for _, it := range x.LinkDependencies {
		fmt.Fprintf(dst, "    MakeStringView(\"%s\"),\n", it.ModuleAlias)
	}
	for _, it := range x.RuntimeDependencies {
		fmt.Fprintf(dst, "    MakeStringView(\"%s\"),\n", it.ModuleAlias)
	}
	fmt.Fprintln(dst, "};")
	fmt.Fprintln(dst, "} //!namespace PPE::Generated")
	return nil
}
func (x BuildModulesGeneratedHeader) getModuleAnchor(alias TargetAlias) string {
	return SanitizeIdentifier(alias.ModuleAlias.String())
}
func (x BuildModulesGeneratedHeader) getModuleClass(alias TargetAlias) string {
	return alias.ModuleName + "Module"
}
func (x BuildModulesGeneratedHeader) getModuleStaticInfo(alias TargetAlias) string {
	return x.getModuleAnchor(alias) + "_StaticInfo"
}

/***************************************
 * PPE custom archetypes
 ***************************************/

func makePPE_Common(rules *ModuleRules) {
	rules.Defines.Append("EXPORT_PPE_" + SanitizeIdentifier(strings.ToUpper(rules.ModuleAlias.String())))

	// HAL handling
	currentHost := CurrentHost()
	for _, hostId := range HostIds() {
		if hostId != currentHost.Id {
			hostName := hostId.String()
			hostName = strings.ToUpper(hostName[0:1]) + strings.ToLower(hostName[1:])

			if halPublic := rules.ModuleDir.Folder("Public", "HAL", hostName); halPublic.Exists() {
				rules.Source.ExcludedGlobs.AppendUniq(halPublic.Folder("*").String())
			}
			if halPrivate := rules.ModuleDir.Folder("Private", "HAL", hostName); halPrivate.Exists() {
				rules.Source.ExcludedGlobs.AppendUniq(halPrivate.Folder("*").String())
			}
		}
	}

	IfWindows(func() {
		rules.LinkerOptions.Append("/NATVIS:\"" + NatvisFile.String() + "\"")
	})
}
func makePPE_Internal(rules *ModuleRules) {
	rules.Source.SourceDirs.Append(rules.PrivateDir())
	rules.Source.SourceGlobs.Append("*.cpp")

	Inherit(&rules.PCH, PCH_MONOLITHIC)

	switch rules.PCH {
	case PCH_MONOLITHIC:
		pch_h := rules.ModuleDir.File("stdafx.h")
		pch_cpp := rules.ModuleDir.File("stdafx.cpp")
		rules.PrecompiledHeader = &pch_h
		rules.PrecompiledSource = &pch_cpp
	case PCH_SHARED:
		LogPanic("Shared PCH are not implemented")
	case PCH_DISABLED:
		// nothing TODO
	default:
		UnexpectedValuePanic(rules.PCH, rules.PCH)
	}

	rules.Generate(PRIVATE, "BuildModules.generated.h", &BuildModulesHeaderGenerator{Version: BuildModulesHeaderVersion})
	rules.Generate(PRIVATE, "BuildVersion.generated.h", &BuildVersionHeaderGenerator{Version: BuildVersionHeaderVersion})
}

func makePPE_Headers(rules *ModuleRules) {
	rules.ModuleType = MODULE_HEADERS
	Inherit(&rules.DebugSymbols, DEBUG_EMBEDDED)
	rules.IncludePaths.Append(CorePublicDir)
}
func makePPE_External(rules *ModuleRules) {
	makePPE_Common(rules)
	rules.ModuleType = MODULE_EXTERNAL
	Inherit(&rules.DebugSymbols, DEBUG_EMBEDDED)
	Inherit(&rules.Unity, UNITY_DISABLED)
	rules.IncludePaths.Append(CorePublicDir)
}
func makePPE_Module(rules *ModuleRules) {
	makePPE_Common(rules)
	makePPE_Internal(rules)
	rules.ModuleType = MODULE_LIBRARY

	moduleCpp := rules.PrivateDir().File(rules.ModuleAlias.ModuleName + "Module.cpp")
	if moduleCpp.Exists() { // isolate module since it's including BuildXXX.generated.h files
		rules.Source.IsolatedFiles.Append(moduleCpp)
	}
}
func makePPE_Program(rules *ModuleRules, usage UsageType) {
	makePPE_Common(rules)
	makePPE_Internal(rules)
	rules.ModuleType = MODULE_PROGRAM
	Inherit(&rules.Link, LINK_STATIC)
	Inherit(&rules.Unity, UNITY_DISABLED)
	rules.Defines.Append("PPE_TARGET_NAME=" + rules.String())
	rules.Defines.Append("PPE_TARGET_USAGE=" + string(usage))
}

/***************************************
 * Build System Entry Point
 ***************************************/

func main() {
	utils.RegisterSerializable(&BuildModulesHeaderGenerator{})
	utils.RegisterSerializable(&BuildModulesGeneratedHeader{})

	utils.RegisterSerializable(&BuildVersionHeaderGenerator{})
	utils.RegisterSerializable(&BuildVersionGeneratedHeader{})

	RegisterArchetype("PPE/Headers", makePPE_Headers)
	RegisterArchetype("PPE/External", makePPE_External)
	RegisterArchetype("PPE/Module", makePPE_Module)

	for _, usage := range UsageTypes() {
		RegisterArchetype("PPE/Program/"+string(usage), func(rules *ModuleRules) {
			makePPE_Program(rules, usage)
		})
	}

	LaunchCommand(
		"ppe",
		UFS.Source.File("Source-namespace.json"),
		os.Args[1:])
}
