package main

import (
	. "build"
	. "build/compile"
	. "build/utils"
	"os"
	"strings"
)

var CorePublicDir = UFS.Source.Folder("Runtime", "Core", "Public")
var NatvisFile = UFS.Extras.Folder("Debug").File("PPE.natvis")

func makePPE_Common(rules *ModuleRules) {
	rules.Defines.Append("EXPORT_PPE_" + strings.Join(rules.Path(), "_"))
	IfWindows(func() {
		rules.LinkerOptions.Append("/NATVIS:\"" + NatvisFile.String() + "\"")
	})
}
func makePPE_Internal(rules *ModuleRules) {
	rules.Source.SourceDirs.Append(rules.PrivateDir())
	rules.Source.SourceGlobs.Append("*.cpp")

	rules.Debug = DEBUG_SYMBOLS
	rules.PCH = PCH_MONOLITHIC

	pch_h := rules.ModuleDir.File("stdafx.h")
	pch_cpp := rules.ModuleDir.File("stdafx.cpp")
	rules.PrecompiledHeader = &pch_h
	rules.PrecompiledSource = &pch_cpp

	// sourceControl := SourceControlBuilder.Build(CommandEnv.BuildGraph())
	// rules.Generate(PRIVATE, "BuildVersion.generated.h",
	// 	func(u Unit, _ GeneratedRules, dst Filename) error {
	// 		return UFS.Create(dst, func(dst io.Writer) error {
	// 			fmt.Fprintln(dst, "#pragma once")
	// 			fmt.Fprintln(dst, "// Build version generated by "+MAIN_SIGNATURE+"/"+u.Alias.String()+" on "+time.Now().String())
	// 			fmt.Fprintln(dst, "#include \"Core_fwd.h\"")
	// 			fmt.Fprintln(dst, "namespace PPE::Generated {")
	// 			fmt.Fprintln(dst, "constexpr const char BuildBranch[] = \""+sourceControl.Branch+"\";")
	// 			fmt.Fprintln(dst, "constexpr const char BuildRevision[] = \""+sourceControl.Revision+"\";")
	// 			fmt.Fprintln(dst, "constexpr const i64  BuildTimestamp = 0x"+strconv.FormatInt(sourceControl.Timestamp.Unix(), 16)+"ll;")
	// 			fmt.Fprintln(dst, "} //!namespace PPE::Generated")
	// 			return nil
	// 		})
	// 	}, sourceControl)

	// rules.Generate(PRIVATE, "BuildModules.generated.h",
	// 	func(u Unit, rules GeneratedRules, dst Filename) error {
	// 		return UFS.Create(dst, func(dst io.Writer) error {
	// 			getModuleAnchor := func(alias TargetAlias) string {
	// 				return SanitizeIdentifier(alias.ModuleId())
	// 			}
	// 			getModuleStaticInfo := func(alias TargetAlias) string {
	// 				return getModuleAnchor(alias) + "_StaticInfo"
	// 			}
	// 			fmt.Fprintln(dst, "#pragma once")
	// 			fmt.Fprintln(dst, "// Build modules generated by "+MAIN_SIGNATURE+"/"+u.Alias.String()+" on "+time.Now().String())
	// 			fmt.Fprintln(dst, "#include \"Core_fwd.h\"")
	// 			fmt.Fprintln(dst, "#include \"IO/StringView.h\"")
	// 			fmt.Fprintln(dst, "#include \"Modular/ModularRegistration.h\"")
	// 			fmt.Fprintln(dst, "#include <array>")
	// 			if u.Payload != PAYLOAD_EXECUTABLE {
	// 				fmt.Fprintln(dst, "// DLL exports for current module:")
	// 				fmt.Fprintln(dst, "extern \"C\" DLL_EXPORT const void* "+getModuleStaticInfo(u.Alias)+"() {")
	// 				fmt.Fprintln(dst, "    return (&::PPE::F"+getModuleAnchor(u.Alias)+"::StaticInfo);")
	// 				fmt.Fprintln(dst, "}")
	// 			}
	// 			fmt.Fprintln(dst, "// DLL imports for current module:")
	// 			for _, x := range u.StaticDependencies.Slice() {
	// 				fmt.Fprintln(dst, "#include \""+x.Alias.ModuleName+"Module.h\"")
	// 				fmt.Fprintln(dst, "extern \"C\" DLL_IMPORT const void* "+getModuleStaticInfo(x.Alias)+"();")
	// 			}
	// 			fmt.Fprintln(dst, "namespace PPE::Generated {")
	// 			fmt.Fprintln(dst, "// register/unregister for static modules:")
	// 			fmt.Fprintln(dst, "inline void RegisterStaticModules() NOEXCEPT {")
	// 			if u.StaticDependencies.Len() > 0 {
	// 				fmt.Fprintln(dst, "    auto& registry = FModuleStaticRegistration::Get();")
	// 				for _, x := range u.StaticDependencies.Slice() {
	// 					fmt.Fprintln(dst, "    registry.RegisterAnchor(&"+getModuleStaticInfo(x.Alias)+");")
	// 				}
	// 			}
	// 			fmt.Fprintln(dst, "}")
	// 			fmt.Fprintln(dst, "inline void UnregisterStaticModules() NOEXCEPT {")
	// 			if u.StaticDependencies.Len() > 0 {
	// 				fmt.Fprintln(dst, "    auto& registry = FModuleStaticRegistration::Get();")
	// 				for _, x := range u.StaticDependencies.Slice() {
	// 					fmt.Fprintln(dst, "    registry.UnregisterAnchor(&"+getModuleStaticInfo(x.Alias)+");")
	// 				}
	// 			}
	// 			fmt.Fprintln(dst, "}")
	// 			fmt.Fprintln(dst, "inline void RegisterDynamicModules() NOEXCEPT {")
	// 			if u.DynamicDependencies.Len() > 0 {
	// 				fmt.Fprintln(dst, "    auto& registry = FModuleDynamicRegistration::Get();")
	// 				for _, x := range u.DynamicDependencies.Slice() {
	// 					fmt.Fprintln(dst, "    registry.RegisterLibrary("+
	// 						"\""+x.ModuleDir.Relative(UFS.Root)+"\","+
	// 						"\""+getModuleStaticInfo(x.Alias)+"\","+
	// 						"L\""+x.OutputFile.Relative(UFS.Binaries)+"\");")
	// 				}
	// 			}
	// 			fmt.Fprintln(dst, "}")
	// 			fmt.Fprintln(dst, "inline void UnregisterDynamicModules() NOEXCEPT {")
	// 			if u.DynamicDependencies.Len() > 0 {
	// 				fmt.Fprintln(dst, "    auto& registry = FModuleDynamicRegistration::Get();")
	// 				for _, x := range u.DynamicDependencies.Slice() {
	// 					fmt.Fprintf(dst, "    registry.UnregisterLibrary(\"%s\");\n",
	// 						x.ModuleDir.Relative(UFS.Root))
	// 				}
	// 			}
	// 			fmt.Fprintln(dst, "}")
	// 			fmt.Fprintln(dst, "} //!namespace PPE::Generated")
	// 			return nil
	// 		})
	// 	})
}

func makePPE_Headers(rules *ModuleRules) {
	rules.ModuleType = MODULE_HEADERS
	rules.Debug = DEBUG_EMBEDDED
	rules.IncludePaths.Append(CorePublicDir)
}
func makePPE_External(rules *ModuleRules) {
	makePPE_Common(rules)
	rules.ModuleType = MODULE_EXTERNAL
	rules.Debug = DEBUG_EMBEDDED
	rules.Unity = UNITY_DISABLED
	rules.IncludePaths.Append(CorePublicDir)
}
func makePPE_Module(rules *ModuleRules) {
	makePPE_Common(rules)
	makePPE_Internal(rules)
	rules.ModuleType = MODULE_LIBRARY
	rules.Unity = UNITY_AUTOMATIC
}
func makePPE_Program(rules *ModuleRules) {
	makePPE_Common(rules)
	makePPE_Internal(rules)
	rules.ModuleType = MODULE_PROGRAM
	rules.Link = LINK_STATIC
	rules.Unity = UNITY_DISABLED
	rules.Defines.Append("PPE_TARGET_NAME=" + rules.String())
}

func main() {
	RegisterArchtype("PPE/Headers", makePPE_Headers)
	RegisterArchtype("PPE/External", makePPE_External)
	RegisterArchtype("PPE/Module", makePPE_Module)
	RegisterArchtype("PPE/Program", makePPE_Program)

	LaunchCommand(
		"ppe",
		UFS.Source.File("Source-namespace.json"),
		os.Args[1:])
}
