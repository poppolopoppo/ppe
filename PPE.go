package main

import (
	. "build"
	. "build/compile"
	. "build/utils"
	"bytes"
	"encoding/gob"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
)

var CorePublicDir = UFS.Source.Folder("Runtime", "Core", "Public")
var NatvisFile = UFS.Extras.Folder("Debug").File("PPE.natvis")

type UsageType string

const (
	USAGE_RUNTIME   UsageType = "Runtime"
	USAGE_SHIPPING  UsageType = "Shipping"
	USAGE_TOOLS     UsageType = "Tools"
	USAGE_DEVELOPER UsageType = "Developer"
)

func UsageTypes() []UsageType {
	return []UsageType{
		USAGE_RUNTIME,
		USAGE_SHIPPING,
		USAGE_TOOLS,
		USAGE_DEVELOPER,
	}
}

type BuildVersionHeader struct{}

func (x BuildVersionHeader) GetDigestable(o *bytes.Buffer) {
	o.WriteString("BuildVersionHeader-1.0.1")
}
func (x BuildVersionHeader) Generate(ctx GeneratorContext, dst io.Writer) error {
	u := ctx.Unit
	sourceControl := SourceControlBuilder.Need(ctx)
	fmt.Fprintln(dst, "#pragma once")
	fmt.Fprintln(dst, "// Build version generated by "+MAIN_SIGNATURE+"/"+u.Target.String())
	fmt.Fprintln(dst, "#include \"Core_fwd.h\"")
	fmt.Fprintln(dst, "namespace PPE::Generated {")
	fmt.Fprintln(dst, "constexpr const char BuildBranch[] = \""+sourceControl.Branch+"\";")
	fmt.Fprintln(dst, "constexpr const char BuildRevision[] = \""+sourceControl.Revision+"\";")
	fmt.Fprintln(dst, "constexpr const i64  BuildTimestamp = "+strconv.FormatInt(sourceControl.Timestamp.Unix(), 10)+"ll;")
	fmt.Fprintln(dst, "} //!namespace PPE::Generated")
	return nil
}

type BuildModulesHeader struct{}

func (x BuildModulesHeader) GetDigestable(o *bytes.Buffer) {
	o.WriteString("BuildModulesHeader-1.0.2")
}
func (x BuildModulesHeader) Generate(ctx GeneratorContext, dst io.Writer) error {
	u := ctx.Unit

	modules := BuildModules.Need(ctx)
	isNotModuleLibrary := func(alias TargetAlias) bool {
		m := modules.Get(alias.GetModuleAlias()).GetModule()
		return m.ModuleType == MODULE_LIBRARY
	}

	linkDependencies := RemoveUnless(isNotModuleLibrary, u.LinkDependencies.Slice()...)
	runtimeDependencies := RemoveUnless(isNotModuleLibrary, u.RuntimeDependencies.Slice()...)

	getModuleAnchor := func(alias TargetAlias) string {
		return SanitizeIdentifier(string(alias.GetModuleAlias()))
	}
	getModuleClass := func(alias TargetAlias) string {
		return alias.ModuleName + "Module"
	}
	getModuleStaticInfo := func(alias TargetAlias) string {
		return getModuleAnchor(alias) + "_StaticInfo"
	}

	fmt.Fprintln(dst, "#pragma once")
	fmt.Fprintln(dst, "// Build modules generated by "+MAIN_SIGNATURE+"/"+u.Target.String())
	fmt.Fprintln(dst, "#include \"Core_fwd.h\"")
	fmt.Fprintln(dst, "#include \"IO/StringView.h\"")
	fmt.Fprintln(dst, "#include \"Modular/ModuleRegistration.h\"")
	fmt.Fprintln(dst, "#include <array>")
	if u.Payload != PAYLOAD_EXECUTABLE {
		fmt.Fprintln(dst, "// DLL exports for current module:")
		fmt.Fprintln(dst, "extern \"C\" DLL_EXPORT const void* "+getModuleStaticInfo(u.Target)+"() {")
		fmt.Fprintln(dst, "    return (&::PPE::F"+getModuleClass(u.Target)+"::StaticInfo);")
		fmt.Fprintln(dst, "}")
	}
	fmt.Fprintln(dst, "// DLL imports for current module:")
	for _, x := range linkDependencies {
		fmt.Fprintln(dst, "#include \""+getModuleClass(x)+".h\"")
		fmt.Fprintln(dst, "extern \"C\" DLL_IMPORT const void* "+getModuleStaticInfo(x)+"();")
	}
	fmt.Fprintln(dst, "namespace PPE::Generated {")
	fmt.Fprintln(dst, "// register/unregister for static modules:")
	fmt.Fprintln(dst, "inline void RegisterStaticModules() NOEXCEPT {")
	if len(linkDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleStaticRegistration::Get();")
		for _, x := range linkDependencies {
			fmt.Fprintln(dst, "    registry.RegisterAnchor(&"+getModuleStaticInfo(x)+");")
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "inline void UnregisterStaticModules() NOEXCEPT {")
	if len(linkDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleStaticRegistration::Get();")
		for _, x := range linkDependencies {
			fmt.Fprintln(dst, "    registry.UnregisterAnchor(&"+getModuleStaticInfo(x)+");")
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "inline void RegisterDynamicModules() NOEXCEPT {")
	if len(runtimeDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleDynamicRegistration::Get();")
		for _, x := range runtimeDependencies {
			fmt.Fprintf(dst, "    registry.RegisterLibrary(\"%s\", \"%s\", L\"%s\");\n",
				x.GetModuleAlias(),
				getModuleStaticInfo(x),
				ctx.Env.GetBinariesOutput(x.GetModuleAlias().String(), PAYLOAD_SHAREDLIB))
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "inline void UnregisterDynamicModules() NOEXCEPT {")
	if len(runtimeDependencies) > 0 {
		fmt.Fprintln(dst, "    auto& registry = FModuleDynamicRegistration::Get();")
		for _, x := range runtimeDependencies {
			fmt.Fprintf(dst, "    registry.UnregisterLibrary(\"%s\");\n",
				x.GetModuleAlias().String())
		}
	}
	fmt.Fprintln(dst, "}")
	fmt.Fprintln(dst, "// list module dependencies by name:")
	fmt.Fprintf(dst, "constexpr std::array<FStringView, %d> DependencyList{\n",
		len(linkDependencies)+len(runtimeDependencies))
	for _, x := range linkDependencies {
		fmt.Fprintf(dst, "    MakeStringView(\"%s\"),\n",
			x.GetModuleAlias().String())
	}
	for _, x := range runtimeDependencies {
		fmt.Fprintf(dst, "    MakeStringView(\"%s\"),\n",
			x.GetModuleAlias().String())
	}
	fmt.Fprintln(dst, "};")
	fmt.Fprintln(dst, "} //!namespace PPE::Generated")
	return nil
}

func makePPE_Common(rules *ModuleRules) {
	rules.Defines.Append("EXPORT_PPE_" + SanitizeIdentifier(strings.ToUpper(strings.Join(rules.Path(), "_"))))
	IfWindows(func() {
		rules.LinkerOptions.Append("/NATVIS:\"" + NatvisFile.String() + "\"")
	})
}
func makePPE_Internal(rules *ModuleRules) {
	rules.Source.SourceDirs.Append(rules.PrivateDir())
	rules.Source.SourceGlobs.Append("*.cpp")

	rules.PCH.Inherit(PCH_MONOLITHIC)
	if rules.PCH == PCH_MONOLITHIC {
		pch_h := rules.ModuleDir.File("stdafx.h")
		pch_cpp := rules.ModuleDir.File("stdafx.cpp")
		rules.PrecompiledHeader = &pch_h
		rules.PrecompiledSource = &pch_cpp
	}

	rules.Generate(PRIVATE, "BuildModules.generated.h", BuildModulesHeader{})
	rules.Generate(PRIVATE, "BuildVersion.generated.h", BuildVersionHeader{})
}

func makePPE_Headers(rules *ModuleRules) {
	rules.ModuleType = MODULE_HEADERS
	rules.Debug.Inherit(DEBUG_EMBEDDED)
	rules.IncludePaths.Append(CorePublicDir)
}
func makePPE_External(rules *ModuleRules) {
	makePPE_Common(rules)
	rules.ModuleType = MODULE_EXTERNAL
	rules.Debug.Inherit(DEBUG_EMBEDDED)
	rules.Unity.Inherit(UNITY_DISABLED)
	rules.IncludePaths.Append(CorePublicDir)
}
func makePPE_Module(rules *ModuleRules) {
	makePPE_Common(rules)
	makePPE_Internal(rules)
	rules.ModuleType = MODULE_LIBRARY

	moduleCpp := rules.PrivateDir().File(rules.ModuleName + "Module.cpp")
	if moduleCpp.Exists() { // isolate module since it's including BuildXXX.generated.h files
		rules.Source.IsolatedFiles.Append(moduleCpp)
	}
}
func makePPE_Program(rules *ModuleRules, usage UsageType) {
	makePPE_Common(rules)
	makePPE_Internal(rules)
	rules.ModuleType = MODULE_PROGRAM
	rules.Link.Inherit(LINK_STATIC)
	rules.Unity.Inherit(UNITY_DISABLED)
	rules.Defines.Append("PPE_TARGET_NAME=" + rules.String())
	rules.Defines.Append("PPE_TARGET_USAGE=" + string(usage))
}

func main() {
	gob.Register(BuildModulesHeader{})
	gob.Register(BuildVersionHeader{})

	RegisterArchtype("PPE/Headers", makePPE_Headers)
	RegisterArchtype("PPE/External", makePPE_External)
	RegisterArchtype("PPE/Module", makePPE_Module)

	for _, usage := range UsageTypes() {
		RegisterArchtype("PPE/Program/"+string(usage), func(rules *ModuleRules) {
			makePPE_Program(rules, usage)
		})
	}

	LaunchCommand(
		"ppe",
		UFS.Source.File("Source-namespace.json"),
		os.Args[1:])
}
