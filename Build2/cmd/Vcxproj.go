package cmd

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"io"
	"os"
)

type VcxprojArgsT struct{}

func (flags *VcxprojArgsT) InitFlags(cfg *PersistentMap) {
}
func (flags *VcxprojArgsT) ApplyVars(cfg *PersistentMap) {
}
func (flags *VcxprojArgsT) Alias() BuildAlias {
	return MakeBuildAlias("Flags", "VcxprojArgs")
}
func (flags *VcxprojArgsT) Build(BuildContext) (BuildStamp, error) {
	return MakeBuildStamp(flags)
}
func (flags *VcxprojArgsT) GetDigestable(o *bytes.Buffer) {
}

var VcxprojArgs = MakeServiceAccessor[ParsableFlags](newVcxprojArgs)

func newVcxprojArgs() *VcxprojArgsT {
	return CommandEnv.BuildGraph().Create(&VcxprojArgsT{}).GetBuildable().(*VcxprojArgsT)
}

var Vcxproj = MakeCommand(
	"vcxproj",
	"generate projects and solution for Visual Studio",
	func(cmd *CommandEnvT) *VcxprojArgsT {
		AllCompilationFlags.Needed(cmd.Flags)
		return VcxprojArgs.Create(cmd.Flags)
	},
	func(cmd *CommandEnvT, args *VcxprojArgsT) error {
		output := UFS.Output.File("vcxproj.bff")
		LogClaim("generating VCXProj config in '%v'", output)

		bg := cmd.BuildGraph()
		builder := bg.Create(&VcxProjBuilder{
			Output: output,
		}, args.Alias())

		_, result := bg.Build(builder)
		if err := result.Join().Failure(); err != nil {
			return err
		}

		fbuildArgs := FBuildArgs{
			BffFile: output,
		}
		fbuildExec := MakeFBuildExecutor(&fbuildArgs)
		return fbuildExec.Run()
	},
)

/***************************************
 * VCXProj/SLN generation
 ***************************************/

type VcxProjBuilder struct {
	Output Filename
}

func (vcx *VcxProjBuilder) Alias() BuildAlias {
	return vcx.Output.Alias()
}
func (vcx *VcxProjBuilder) Build(bc BuildContext) (BuildStamp, error) {
	args := VcxprojArgs.Need(CommandEnv.Flags)
	modules := BuildModules.Need(bc)
	targets := BuildTargets.Need(bc)
	bc.DependsOn(args, modules, targets)

	moduleGraph := GetModuleGraph(modules)
	moduleGraph.Keys()

	err := UFS.SafeCreate(vcx.Output, func(wr io.Writer) error {
		bff := NewBffFile(wr, false)
		bff.Comment("BFF generated by %v", MAIN_SIGNATURE)

		selfExecutable, err := os.Executable()
		if err != nil {
			panic(err)
		}

		bff.Assign("BaseProjectBuildCommand", selfExecutable+" fbuild -v ")
		bff.Assign("BaseProjectRebuildCommand", selfExecutable+" fbuild -v -Clean ")
		bff.Assign("BaseProjectCleanCommand", selfExecutable+" distclean -v ")

		compileEnvs := NewSet[EnvironmentAlias]()
		moduleUnits := make(map[Module]*BffArray, targets.Len())
		for _, x := range targets.Slice() {
			configVar := vcx.vcxconfig(bff, x)
			module := moduleGraph.Module(x.Target.ModuleAlias())

			if arr, ok := moduleUnits[module]; ok {
				*arr = append(*arr, configVar)
			} else {
				arr := MakeBffArray(configVar)
				moduleUnits[module] = &arr
			}

			compileEnvs.AppendUniq(x.Target.EnvironmentAlias)
		}

		buildProjects := NewStringSet()
		solutionFolders := make(map[string]*StringSet, targets.Len())
		for module, configVars := range moduleUnits {
			moduleRules := module.GetModule()
			relativePath := moduleRules.ModuleDir.Relative(UFS.Source)

			moduleId := SanitizeIdentifier(relativePath)
			outputDir := UFS.Projects.AbsoluteFolder(relativePath)

			moduleVcxprojet := moduleId + "-vcxproject"
			bff.Func("VCXProject", func() {
				bff.Assign("ProjectBasePath", moduleRules.ModuleDir)
				bff.Assign("ProjectOutput", outputDir.String()+".vcxproj")
				bff.Assign("ProjectConfigs", *configVars)
				bff.Assign("ProjectInputPaths", moduleRules.Source.SourceDirs)
				bff.Assign("ProjectAllowedFileExtensions",
					NewStringSet(append(moduleRules.Source.SourceGlobs, "*.h", "*.rc")...))
				bff.Assign("ProjectFiles",
					moduleRules.Source.ExtraFiles.ConcatUniq(
						moduleRules.ForceIncludes...,
					).ConcatUniq(
						moduleRules.Source.IsolatedFiles...,
					).ConcatUniq(
						moduleRules.Source.SourceFiles...,
					))
				bff.Assign("ProjectFilesToExclude", moduleRules.Source.ExcludedFiles)
			}, moduleVcxprojet)

			if list, ok := solutionFolders[module.GetNamespace().String()]; ok {
				list.Append(moduleVcxprojet)
			} else {
				list := NewStringSet(moduleVcxprojet)
				solutionFolders[module.GetNamespace().String()] = &list
			}

			if moduleRules.ModuleType != MODULE_HEADERS {
				buildProjects.Append(moduleVcxprojet)
			}
		}

		bff.Func("VSSolution", func() {
			bff.Assign("SolutionVisualStudioVersion", "16")
			bff.Assign("SolutionOutput", UFS.Output.File(CommandEnv.Prefix()+".sln"))
			bff.Assign("SolutionBuildProjects", buildProjects)
			bff.Assign("SolutionConfigs", MakeBffArray(Map(func(a EnvironmentAlias) interface{} {
				result := BffVar(SanitizeIdentifier(a.CompileEnvAlias().String()))
				bff.Struct(result, func() {
					bff.Assign("Platform", vcx.solutionPlatform(a.PlatformName))
					bff.Assign("Config", a.ConfigName)
				})
				return result
			}, compileEnvs...)...))
			bff.Assign("SolutionFolders", MakeBffArray(Map(func(namespace string) BffVar {
				result := BffVar("Folder_" + SanitizeIdentifier(namespace))
				bff.Struct(result, func() {
					bff.Assign("Path", namespace)
					bff.Assign("Projects", solutionFolders[namespace])
				})
				return result
			}, Keys(solutionFolders)...)...))

			hasVcxproject := false
			for _, moduleVcxprojects := range solutionFolders {
				if moduleVcxprojects.Len() > 0 {
					if hasVcxproject {
						bff.Append("SolutionProjects", moduleVcxprojects)
					} else {
						hasVcxproject = true
						bff.Assign("SolutionProjects", moduleVcxprojects)
					}
				}
			}
		}, "all")

		return nil
	})

	if err == nil {
		return vcx.Output.Build(bc)
	} else {
		return BuildStamp{}, err
	}
}

func (x *VcxProjBuilder) solutionPlatform(platformName string) string {
	switch platformName {
	case "Win32":
		return "Win32"
	case "Win64":
		return "x64"
	default:
		UnexpectedValue(platformName)
		return ""
	}
}
func (x *VcxProjBuilder) vcxconfig(bff *BffFile, u *Unit) BffVar {
	configVar := MakeBffVar(u.String())
	bff.Struct(configVar, func() {
		bff.Assign("Platform", x.solutionPlatform(u.Target.PlatformName))
		bff.Assign("Config", u.Target.ConfigName)
		bff.Assign("PlatformToolset", "v"+u.Facet.Exports.Get("VisualStudio/PlatformToolset"))
		bff.Assign("IntermediateDirectory", u.IntermediateDir)
		bff.Assign("BuildLogFile", u.IntermediateDir.File("BuildLog.log"))
		bff.Assign("AdditionalOptions", u.AnalysisOptions.Join(" "))
		bff.Assign("PreprocessorDefinitions", u.Defines.Join(";"))
		bff.Assign("ForcedIncludes", u.ForceIncludes.StringSet().Join(";"))

		includeSearchPaths := NewDirSet(u.IncludePaths...)
		includeSearchPaths.Append(u.ExternIncludePaths...)
		includeSearchPaths.Append(u.SystemIncludePaths...)
		bff.Assign("IncludeSearchPath", includeSearchPaths.StringSet().Join(";"))

		if u.Payload.HasOutput() {
			target := u.Target.String()
			bff.Assign("ProjectBuildCommand", "$BaseProjectBuildCommand$ "+target)
			bff.Assign("ProjectRebuildCommand", "$BaseProjectRebuildCommand$ "+target)
			bff.Assign("ProjectCleanCommand", "$BaseProjectCleanCommand$ "+target)

			if u.Payload == PAYLOAD_EXECUTABLE {
				bff.Assign("LocalDebuggerCommand", u.OutputFile)
				bff.Assign("LocalDebuggerWorkingDirectory", u.OutputFile.Dirname)
				bff.Assign("LocalDebuggerEnvironment", "PATH="+u.Compiler.EnvPath().Join(";")+";%PATH%&#xA;^$(LocalDebuggerEnvironment)")
			}
		}
	})
	return configVar
}
