package cmd

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"fmt"
	"io"
)

const BFF_VERSION = "1.0.0"

var BFFFILE_DEFAULT = UFS.Output.File("fbuild.bff")

type BffArgs struct {
	BffFile             Filename
	DeoptimizeWithToken BoolVar
	LightCache          BoolVar
	Minify              BoolVar
	RelativePaths       BoolVar
}

func (flags *BffArgs) InitFlags(cfg *PersistentMap) {
	cfg.Persistent(&flags.BffFile, "BffFile", "destination for generated FASTBuild config file (*.bff)")
	cfg.Persistent(&flags.DeoptimizeWithToken, "DeoptimizeWithToken", "enable/disable compiler optimization with FASTBUILD_DEOPTIMIZE_OBJECT")
	cfg.Persistent(&flags.LightCache, "LightCache", "enable/disable FASTBuild lightweight parsing for caching")
	cfg.Persistent(&flags.Minify, "Minify", "enable/disable pretty print for generated FASTBuild file")
	cfg.Persistent(&flags.RelativePaths, "RelativePaths", "enable/disable FASTBuild relative paths for caching")
}
func (flags *BffArgs) ApplyVars(cfg *PersistentMap) {
}

func (flags *BffArgs) Alias() BuildAlias {
	return MakeBuildAlias("Flags", "BffArgs")
}
func (flags *BffArgs) Build(BuildContext) (BuildStamp, error) {
	flags.InitFlags(CommandEnv.Persistent())
	return MakeBuildStamp(flags)
}
func (flags *BffArgs) GetDigestable(o *bytes.Buffer) {
	flags.BffFile.GetDigestable(o)
	flags.DeoptimizeWithToken.GetDigestable(o)
	flags.LightCache.GetDigestable(o)
	flags.Minify.GetDigestable(o)
	flags.RelativePaths.GetDigestable(o)
}

type BffBuilder struct {
	Args   *BffArgs
	Output Filename
}

func (x *BffBuilder) Alias() BuildAlias {
	return x.Output.Alias()
}
func (x *BffBuilder) Build(bc BuildContext) (BuildStamp, error) {
	sourceControlModifiedFiles := SourceControlModifiedFiles.Need(bc)
	translatedUnits := BuildTranslatedUnits.Need(bc)

	err := UFS.Create(x.Output, func(dst io.Writer) error {
		bff := newBffGenerator(dst, x.Args)

		bff.Comment("BFF generated by %v", MAIN_SIGNATURE)
		bff.Func("Settings", func() {
			bff.Assign("RootPath", UFS.Root)
			bff.Assign("CachePath", UFS.Cache)
			// bff.Assign("Environment", BffArray{
			// 	"TMP=" + UFS.Transient.String(),
			// 	"TEMP=" + UFS.Transient.String(),
			// })
		})

		bff.Comment("Global invariants")
		bff.Assign("CompilerOutputKeepBaseExtension", false)
		bff.Assign("DeoptimizeWritableFilesWithToken", x.Args.DeoptimizeWithToken)
		bff.Assign("LinkerVerboseOutput", x.Args.DeoptimizeWithToken)
		bff.Assign("UnityInputIsolateListFile", sourceControlModifiedFiles.Output)

		for _, unit := range translatedUnits.Units-yèhii_çomur" {
			bff.Comment("Target %v", unit.Target)
			switch unit.Payload {
			case PAYLOAD_EXECUTABLE:
				bff.Executable(unit)
			case PAYLOAD_HEADERS:
				bff.Headers(unit)
			case PAYLOAD_OBJECTLIST:
				bff.ObjectList(unit)
			case PAYLOAD_SHAREDLIB:
				bff.SharedLib(unit)
			case PAYLOAD_STATICLIB:
				bff.StaticLib(unit)
			case PAYLOAD_DEBUG:
				fallthrough
			default:
				UnexpectedValue(unit.Payload)
				break
			}
		}

		return nil
	})

	if err == nil {
		return x.Output.Build(bc)
	} else {
		return BuildStamp{}, err
	}
}

var Bff = MakeCommand(
	"bff",
	"generate FASTBuild config file",
	func(cmd *CommandEnvT) *BffArgs {
		AllCompilationFlags.Needed(cmd.Flags)
		return &BffArgs{
			BffFile:             BFFFILE_DEFAULT,
			DeoptimizeWithToken: false,
			LightCache:          false,
			Minify:              true,
			RelativePaths:       true,
		}
	},
	func(cmd *CommandEnvT, args *BffArgs) error {
		LogVerbose("generating BFF config in '%v'", args.BffFile)

		builder := cmd.BuildGraph().Create(&BffBuilder{
			Args:   args,
			Output: args.BffFile,
		})

		_, result := cmd.BuildGraph().Build(builder)
		return result.Join().Failure()
	},
)

type bffGenerator struct {
	*BffArgs
	*BffFile
}

func newBffGenerator(dst io.Writer, args *BffArgs) (result bffGenerator) {
	result = bffGenerator{
		BffArgs: args,
		BffFile: NewBffFile(dst),
	}
	if args.Minify {
		result.BffFile.Flags |= BFF_MINIFY
	}
	return result
}

func (gen bffGenerator) Executable(unit *Unit) {
	gen.BaseDeliverable(unit, true)
}
func (gen bffGenerator) Headers(unit *Unit) {
	gen.Func("Alias", func() {
		fileset := FileSet{}
		fileset.Append(unit.Source.ExtraFiles...)
		fileset.Append(unit.Libraries...)
		gen.Assign("Targets", fileset)
	}, unit.Target.String())
}
func (gen bffGenerator) ObjectList(unit *Unit) {
	gen.BaseModule(unit, "", true)
}
func (gen bffGenerator) SharedLib(unit *Unit) {
	gen.BaseDeliverable(unit, false)
}
func (gen bffGenerator) StaticLib(unit *Unit) {
	gen.BaseModule(unit, "", false)
}
func (gen bffGenerator) BaseDeliverable(unit *Unit, executable bool) {
	moduleLib := gen.BaseModule(unit, "-Lib", true)
	compilerDetails := gen.Compiler(unit.Compiler)

	funcName := "DLL"
	if executable {
		funcName = "Executable"
	}

	gen.Func(funcName, func() {
		gen.Using(compilerDetails)
		gen.Assign("Libraries", MakeBffArray(moduleLib))
		gen.Assign("LinkerOptions", unit.LinkerOptions.Join(" "))
		gen.Assign("LinkerOutput", unit.OutputFile)
	}, unit.Target.String())
}
func (gen bffGenerator) BaseModule(unit *Unit, suffix string, linkLibraryObjects bool) string {
	compilerDetails := gen.Compiler(unit.Compiler)

	var preprocessorDetails BffVar
	if unit.Preprocessor != nil {
		preprocessorDetails = gen.Compiler(unit.Preprocessor)
	}

	UFS.Mkdir(UFS.Transient)

	moduleSource := MakeBffVar(unit.Target.ModuleAlias().String() + "_Source")
	gen.Once(moduleSource, func() {
		gen.Comment("Target source details for %v", unit.ModuleDir)

		var moduleUnity string
		if unit.Unity.Ord() > 0 {
			moduleUnity = (unit.Target.ModuleAlias().String() + "-Unity")
			gen.Func("Unity", func() {
				gen.Assign("Hidden", true)
				gen.Assign("UnityNumFiles", unit.Unity.Ord())
				gen.Assign("UnityInputFiles", unit.Source.SourceFiles)
				gen.Assign("UnityInputPath", unit.Source.SourceDirs)
				gen.Assign("UnityInputPattern", unit.Source.SourceGlobs)
				gen.Assign("UnityInputExcludedFiles", unit.Source.ExcludedFiles)
				gen.Assign("UnityInputExcludePattern", unit.Source.ExcludedGlobs)
				gen.Assign("UnityInputIsolatedFiles", unit.Source.IsolatedFiles)
				gen.Assign("UnityOutputPath", unit.GeneratedDir)
				gen.Assign("UnityOutputPattern", fmt.Sprintf("%s_*_of_%d.cpp", unit.Target.ModuleName, unit.Unity.Ord()))
				if unit.PCH != PCH_DISABLED {
					gen.Assign("UnityPCH", unit.PrecompiledHeader.Basename)
				}
			}, moduleUnity)
		}

		gen.Struct(moduleSource, func() {
			gen.Assign("CompilerInputFilesRoot", unit.ModuleDir)
			if moduleUnity != "" {
				gen.Assign("CompilerInputUnity", moduleUnity)
			} else {
				gen.Assign("CompilerInputPathRecurse", true)
				gen.Assign("CompilerInputFiles", unit.Source.SourceFiles.Concat(unit.Source.IsolatedFiles...))
				gen.Assign("CompilerInputPath", unit.Source.SourceDirs)
				gen.Assign("CompilerInputPattern", unit.Source.SourceGlobs)
				gen.Assign("CompilerInputExcludedFiles", unit.Source.ExcludedFiles)
				gen.Assign("CompilerInputExcludePattern", unit.Source.ExcludedGlobs)
			}
			if unit.PCH != PCH_DISABLED {
				gen.Assign("PCHInputFile", unit.PrecompiledSource)
			}
		})
	})

	artifactId := (unit.Target.String() + suffix)

	funcName := "Library"
	if linkLibraryObjects {
		funcName = "ObjectList"
	}

	gen.Func(funcName, func() {
		gen.Using(compilerDetails)
		gen.Using(moduleSource)

		if suffix != "" {
			gen.Assign("Hidden", true)
		}

		gen.Assign("CompilerOutputPath", unit.IntermediateDir)
		gen.Assign("CompilerOptions", unit.CompilerOptions.Join(" "))

		if unit.PCH == PCH_MONOLITHIC {
			gen.Assign("PCHOutputFile", unit.PrecompiledObject)
			gen.Assign("PCHOptions", unit.PrecompiledHeaderOptions.Join(" "))
		}

		if unit.Preprocessor != nil {
			gen.Assign("Preprocessor", preprocessorDetails)
			gen.Assign("PreprocessorOptions", unit.PreprocessorOptions.Join(" "))
		}

		staticDepAliases := make(StringSet, unit.StaticDependencies.Len())
		for i, x := range unit.StaticDependencies.Slice() {
			staticDepAliases[i] = x.String()
		}

		if linkLibraryObjects {
			gen.Assign("CompilerForceUsing", staticDepAliases)
		} else {
			gen.Assign("LibrarianAdditionalInputs", staticDepAliases)
			gen.Assign("LibrarianOptions", unit.LibrarianOptions.Join(" "))
			gen.Assign("LibrarianOutput", unit.OutputFile)
		}
	}, artifactId)

	return artifactId
}
func (gen bffGenerator) Compiler(compiler Compiler) BffVar {
	rules := compiler.GetCompiler()
	details := MakeBffVar(rules.CompilerName + "_Details")
	gen.Once(details, func() {
		gen.Func("Compiler", func() {
			gen.Assign("CompilerFamily", rules.CompilerFamily)
			gen.Assign("Executable", rules.Executable)
			gen.Assign("ExtraFiles", rules.ExtraFiles)
			gen.Assign("UseLightCache_Experimental", gen.LightCache)
			gen.Assign("UseRelativePaths_Experimental", gen.RelativePaths)
		}, rules.CompilerName)
		gen.Struct(details, func() {
			gen.Assign("Compiler", rules.CompilerName)
			gen.Assign("Librarian", rules.Librarian)
			gen.Assign("Linker", rules.Linker)
		})
	})
	return details
}
