#!/usr/bin/env ruby

require 'fileutils'
require 'pathname'

START_TIME=Time.now

VERSION='2.6'
VERSION_HEADER="// VERSION = <#{VERSION}>"

require 'rbconfig'
RUBY_INTERPRETER_PATH = Pathname.new(File.join(
    RbConfig::CONFIG["bindir"],
    RbConfig::CONFIG["RUBY_INSTALL_NAME"] +
    RbConfig::CONFIG["EXEEXT"] )).realpath.to_s

SOLUTION_ROOT = Pathname.new(File.dirname(__FILE__)).realpath.to_s
SOLUTION_FBUILDROOT = File.join(SOLUTION_ROOT, 'Build')
SOLUTION_PATHFILE = File.join(SOLUTION_FBUILDROOT, '_solution_path.bff')

Dir.chdir(SOLUTION_ROOT)

YIELD_PARAMS = ARGV.clone

class FHeader
    attr_reader :filename, :header
    def initialize(filename)
        @filename = filename
        @header = nil
    end
    def match?(other)
        return (@filename == other.filename && @header == other.header)
    end
    def read?()
        @header = File.exist?(@filename) ? File.read(@filename) : nil
    end
    def write!()
        filename_old = @filename + '.old'
        FileUtils.mv(@filename, filename_old) if File.exist?(@filename)
        File.write(@filename, header)
    end

    def print(txt)
        @header = '' if @header.nil?
        @header += txt
        return self
    end
    def puts(txt='')
        self.print(txt + "\n")
    end
    def comment(txt)
        self.print("\n// #{txt}\n")
    end
    def define(name, enabled=true)
        self.print("#{enabled ? '#' : ';'}define WITH_#{name.to_s.upcase}\n")
    end
    def set(name, value)
        if value
            self.print(".#{name} = '#{value.gsub('\\', '/')}'\n")
        else
            self.print(";#{name} = 'XXX'\n")
        end
    end
end

def touch_header(filename)
    File.open(filename, 'r') do |f|
        return f.read(VERSION_HEADER.length)
    end
end

class FDependency
    attr_reader :name, :available, :force_tag
    def initialize(name)
        @name = name
    end
    def eval()
        @available = eval_()
        #puts "Evaluate dependency : #{@name} = #{@available ? 'ENABLED' : 'DISABLED'}"
    end
    def export(header)
        header.define(@name, @available)
    end
    def force_usage()
        if @available
            return FORCE_USAGE.include?(@force_tag)
        else
            return false
        end
    end
private
    def eval_()
        return false
    end
end

class FDirectoryDependency < FDependency
    attr_reader :var, :path
    def initialize(name, var, path)
        super(name)
        @var = var
        @path = path
    end
    def export(header)
        super(header)
        header.set(var, @available ? @path : nil)
    end
private
    def eval_()
        return Dir.exist?(@path)
    end
end

class FPlatform
    attr_reader :name, :dependencies
    def initialize(name)
        @name = name
        @dependencies = {}
    end
    def depends(name, dependency)
        dependency.eval()
        @dependencies[name] = dependency
    end
end #~ FPlatform

require "#{SOLUTION_ROOT}/Build/OS.rb"
require "#{SOLUTION_ROOT}/Build/#{OS.name}/Platform.rb"

newHeader = FHeader.new(SOLUTION_PATHFILE)
newHeader.puts VERSION_HEADER
newHeader.comment("File generated by fbuild.rb")
newHeader.set("OS", SOLUTION_PLATFORM.name)
newHeader.set("SolutionPath", SOLUTION_ROOT)
newHeader.set("RubyInterpreterPath", RUBY_INTERPRETER_PATH)

SOLUTION_PLATFORM.dependencies.each do |(friendly, dep)|
    newHeader.comment("Depends on #{friendly} : #{dep.available ? 'ENABLED' : 'DISABLED'}")
    dep.export(newHeader)
end

oldHeader = FHeader.new(SOLUTION_PATHFILE)
oldHeader.read?()

unless oldHeader.match?(newHeader)
    puts "Regen solution bff : #{SOLUTION_PATHFILE}"
    newHeader.write!()
end

SOURCE_FILES_PATTERN=/\.cpp$/
MODIFIED_FILES_SRC=File.join(SOLUTION_ROOT, 'Source')
MODIFIED_FILES_LIST=File.join(SOLUTION_ROOT, 'Build', '.modified_files')
def git_modified_files()
    outp = `git status --porcelain=v1 -u normal "#{MODIFIED_FILES_SRC}"`
    return outp.split("\n").collect! do |l|
        l.chomp!
        fname = l[3..-1]
        next unless fname =~ SOURCE_FILES_PATTERN
        fname = File.join(SOLUTION_ROOT, fname)
        fname.gsub!('/', '\\') if RUNNING_ON_WINDOWS
        fname
    end
    .delete_if {|fname| fname.nil? || fname.length == 0 || !File.exist?(fname) }
    .sort!
end

File.open(MODIFIED_FILES_LIST, 'w') do |f|
    modifieds = git_modified_files()
    if modifieds.length > 0
        puts "#{modifieds.length} modified source files according to git"
        modifieds.each do |fname|
            f.puts(fname)
        end
    end
end

END_TIME=Time.now

$stdout.puts("Spent %5.3f milliseconds in #{__FILE__}" % [(END_TIME - START_TIME)*1000])
$stdout.puts("#{SOLUTION_FBUILDCMD} #{YIELD_PARAMS.join(' ')}")
$stdout.flush
unless exec(SOLUTION_FBUILDCMD, *YIELD_PARAMS)
    $stderr.puts "failed to start fastbuild, command line:"
    $stderr.puts([SOLUTION_FBUILDCMD, *YIELD_PARAMS].join(' '))
    exit 5
end
