package cmd

import (
	. "build/compile"
	. "build/utils"
	"io"
	"os"
	"strings"
)

var CommandVcxproj = NewCommand(
	"Configure",
	"vcxproj",
	"generate projects and solution for Visual Studio",
	OptionCommandParsableAccessor("solution_flags", "solution generation option", GetSolutionFlags),
	OptionCommandRun(func(cc CommandContext) error {
		bg := CommandEnv.BuildGraph()
		node := bg.Create(&VcxprojBuilder{
			Output: UFS.Output.File("vcxproj.bff"),
		}, BuildAliases{})

		vcx := node.GetBuildable().(*VcxprojBuilder)

		LogClaim("generating VCXProj solution in '%v'", vcx.SolutionFile())

		_, result := bg.Build(node)
		if err := result.Join().Failure(); err != nil {
			return err
		}

		fbuildArgs := FBuildArgs{
			BffInput: vcx.Output,
		}

		fbuildExec := MakeFBuildExecutor(&fbuildArgs)
		fbuildExec.Capture = false

		return fbuildExec.Run()
	}))

/***************************************
 * Solution Flags (also used by VSCode)
 ***************************************/

type SolutionFlags struct {
	FASTBuild BoolVar
}

var GetSolutionFlags = NewCommandParsableFlags(&SolutionFlags{
	FASTBuild: INHERITABLE_FALSE,
})

func (x *SolutionFlags) Flags(cfv CommandFlagsVisitor) {
	cfv.Persistent("FASTBuild", "use FASTBuild for solution compilation", &x.FASTBuild)
}

/***************************************
 * VCXProj/SLN generation
 ***************************************/

type VcxProject struct {
	ModuleDir     Directory
	Aliases       StringSet
	InputPaths    DirSet
	SourceFiles   FileSet
	SourceGlobs   StringSet
	ExcludedFiles FileSet
	ShouldBuild   bool
}

func (x *VcxProject) Serialize(ar Archive) {
	ar.Serializable(&x.ModuleDir)
	ar.Serializable(&x.Aliases)
	ar.Serializable(&x.InputPaths)
	ar.Serializable(&x.SourceFiles)
	ar.Serializable(&x.SourceGlobs)
	ar.Serializable(&x.ExcludedFiles)
	ar.Bool(&x.ShouldBuild)
}

type VcxprojBuilder struct {
	Output       Filename
	environments SetT[EnvironmentAlias]
	projects     map[ModuleAlias]VcxProject
}

func (vcx *VcxprojBuilder) Alias() BuildAlias {
	return MakeBuildAlias("Vcxproj", vcx.Output.String())
}
func (vcx *VcxprojBuilder) SolutionFile() Filename {
	return UFS.Output.File(CommandEnv.Prefix() + ".sln")
}
func (vcx *VcxprojBuilder) Serialize(ar Archive) {
	ar.Serializable(&vcx.Output)
	SerializeSlice(ar, vcx.environments.Ref())
	SerializeMap(ar, &vcx.projects)
}
func (vcx *VcxprojBuilder) Build(bc BuildContext) error {
	translatedUnits := SetT[*Unit]{}
	err := ForeachEnvironmentAlias(func(ea EnvironmentAlias) error {
		buildTargets, err := GetBuildTargets(ea).Need(bc)
		if err != nil {
			return err
		}
		if units, err := buildTargets.GetTranslatedUnits(); err == nil {
			translatedUnits.Append(units...)
		} else {
			return err
		}
		return nil
	})
	if err != nil {
		return err
	}

	vcx.environments = NewSet[EnvironmentAlias]()
	vcx.projects = make(map[ModuleAlias]VcxProject, translatedUnits.Len())

	err = UFS.SafeCreate(vcx.Output, func(wr io.Writer) error {
		bff := NewBffFile(wr, false)
		bff.Comment("BFF generated by %v", PROCESS_INFO)

		selfExecutable, err := os.Executable()
		if err != nil {
			return err
		}

		if solutionFlags := GetSolutionFlags(); solutionFlags.FASTBuild.Get() {
			bff.Assign("BaseProjectBuildCommand", selfExecutable+" fbuild -Ide ")
			bff.Assign("BaseProjectRebuildCommand", selfExecutable+" fbuild -Ide -Clean ")
			bff.Assign("BaseProjectCleanCommand", selfExecutable+" distclean -Ide ")
		} else {
			bff.Assign("BaseProjectBuildCommand", selfExecutable+" build -Ide ")
			bff.Assign("BaseProjectRebuildCommand", selfExecutable+" build -Ide -Rebuild ")
			bff.Assign("BaseProjectCleanCommand", selfExecutable+" build -Ide -Clean ")
		}

		bff.Assign("ProjectPatternToExclude", NewStringSet(
			"*/.vs/*",
			"*/.vscode/*"))

		for _, unit := range translatedUnits.Slice() {
			configVar := vcx.vcxconfig(bff, unit)

			inputPaths := unit.Source.SourceDirs.Concat(unit.Source.ExtraDirs...)
			publicDir := unit.ModuleDir.Folder("Public")
			if publicDir.Exists() {
				inputPaths.Append(publicDir)
			}

			sourceFiles := unit.Source.ExtraFiles.
				ConcatUniq(unit.Source.IsolatedFiles...).
				ConcatUniq(unit.Source.SourceFiles...).
				ConcatUniq(unit.ForceIncludes...)

			if unit.PCH != PCH_DISABLED {
				sourceFiles.AppendUniq(unit.PrecompiledHeader)
				sourceFiles.AppendUniq(unit.PrecompiledSource)
			}

			if gitignore := unit.ModuleDir.File(".gitignore"); gitignore.Exists() {
				sourceFiles.AppendUniq(gitignore)
			}

			project, ok := vcx.projects[unit.Target.ModuleAlias]
			if !ok {
				project = VcxProject{
					ModuleDir:     unit.ModuleDir,
					Aliases:       StringSet{},
					InputPaths:    NewDirSet(),
					SourceFiles:   NewFileSet(),
					SourceGlobs:   NewStringSet(),
					ExcludedFiles: NewFileSet(),
					ShouldBuild:   false,
				}
			}
			Assert(func() bool { return project.ModuleDir.Equals(unit.ModuleDir) })

			project.Aliases.Append(configVar.String())
			project.InputPaths.AppendUniq(inputPaths...)
			project.SourceFiles.AppendUniq(sourceFiles...)
			project.SourceGlobs.AppendUniq(unit.Source.SourceGlobs...)
			project.ExcludedFiles.AppendUniq(unit.Source.ExcludedFiles...)
			project.ShouldBuild = project.ShouldBuild || unit.Payload != PAYLOAD_HEADERS

			vcx.environments.AppendUniq(unit.Target.EnvironmentAlias)

			vcx.projects[unit.Target.ModuleAlias] = project
		}

		buildProjects := NewStringSet()
		solutionFolders := make(map[string]*StringSet, translatedUnits.Len())
		for module, project := range vcx.projects {
			relativePath := project.ModuleDir.Relative(UFS.Source)

			moduleId := SanitizeIdentifier(relativePath)
			outputDir := UFS.Projects.AbsoluteFolder(relativePath)

			moduleVcxprojet := moduleId + "-vcxproject"
			bff.Func("VCXProject", func() {
				bff.Assign("ProjectBasePath", project.ModuleDir)
				bff.Assign("ProjectOutput", outputDir.String()+".vcxproj")
				bff.Assign("ProjectConfigs", BffArray(Map(func(in string) interface{} { return BffVar(in) /* already sanitized */ }, project.Aliases...)))
				bff.Assign("ProjectInputPaths", project.InputPaths)
				bff.Assign("ProjectAllowedFileExtensions",
					NewStringSet(append(project.SourceGlobs, "*.h", "*.rc")...))
				bff.Assign("ProjectFiles", project.SourceFiles)
				bff.Assign("ProjectFilesToExclude", project.ExcludedFiles)
			}, moduleVcxprojet)

			if list, ok := solutionFolders[module.NamespaceName]; ok {
				list.Append(moduleVcxprojet)
			} else {
				list := NewStringSet(moduleVcxprojet)
				solutionFolders[module.NamespaceName] = &list
			}

			if project.ShouldBuild {
				buildProjects.Append(moduleVcxprojet)
			}
		}

		{ // meta project for build inspection/regen/natvis
			moduleVcxprojet := "BuildConfig-vcxproject"
			buildProjects.Append(moduleVcxprojet)
			solutionFolders["Build"] = &StringSet{moduleVcxprojet}

			bff.Func("VCXProject", func() {
				sourceFiles := NewFileSet( // #TODO: this is very project specific
					GetBffArgs().BffOutput,
					vcx.Output,
					UFS.Root.File("PPE.go"),
					UFS.Root.File("README.md"),
					UFS.Root.File("TODO.md"),
					UFS.Source.File("cpp.hint"),
					UFS.Source.File(".gitignore"),
					UFS.Source.File("winnt_version.h"),
					UFS.Extras.Folder("Debug").File("PPE.natvis"))

				bff.Assign("ProjectBuildCommand", selfExecutable+" bff -v -and vcxproj -and vscode")
				bff.Assign("ProjectRebuildCommand", selfExecutable+" bff -v -f -and vcxproj -and vscode")
				bff.Assign("ProjectCleanCommand", selfExecutable+" distclean -v -F")

				configVars := BffArray{}
				for _, env := range vcx.environments.Slice() {
					configVar := MakeBffVar("BuildConfig-" + env.String())
					bff.Struct(configVar, func() {
						bff.Assign("Platform", vcx.solutionPlatform(env.PlatformName))
						bff.Assign("Config", env.ConfigName)
					})
					configVars = append(configVars, configVar)
				}

				bff.Assign("ProjectBasePath", UFS.Root)
				bff.Assign("ProjectOutput", UFS.Projects.AbsoluteFolder("BuildConfig").String()+".vcxproj")
				bff.Assign("ProjectConfigs", configVars)
				bff.Assign("ProjectInputPaths", NewDirSet(UFS.Build, UFS.Source))
				bff.Assign("ProjectAllowedFileExtensions", NewStringSet("*.go", "*.bff", "*.json", "*.exe"))
				bff.Assign("ProjectFiles", sourceFiles)
			}, moduleVcxprojet)
		}

		bff.Func("VSSolution", func() {
			bff.Assign("SolutionVisualStudioVersion", "16") // #TODO: not hard-coding visual studio version
			bff.Assign("SolutionOutput", vcx.SolutionFile())
			bff.Assign("SolutionBuildProject", buildProjects)
			bff.Assign("SolutionConfigs", BffArray(Map(func(a EnvironmentAlias) interface{} {
				result := MakeBffVar(a.String())
				bff.Struct(result, func() {
					bff.Assign("Platform", vcx.solutionPlatform(a.PlatformName))
					bff.Assign("Config", a.ConfigName)
				})
				return result
			}, vcx.environments.Slice()...)))
			bff.Assign("SolutionFolders", BffArray(Map(func(namespace string) interface{} {
				result := MakeBffVar("Folder_" + namespace)
				bff.Struct(result, func() {
					bff.Assign("Path", namespace)
					bff.Assign("Projects", solutionFolders[namespace])
				})
				return result
			}, Keys(solutionFolders)...)))

			hasVcxproject := false
			for _, moduleVcxprojects := range solutionFolders {
				if moduleVcxprojects.Len() > 0 {
					if hasVcxproject {
						bff.Append("SolutionProjects", moduleVcxprojects)
					} else {
						hasVcxproject = true
						bff.Assign("SolutionProjects", moduleVcxprojects)
					}
				}
			}
		}, "all")

		return nil
	})

	if err == nil {
		bc.OutputFile(vcx.Output)
	}
	return err
}
func (x *VcxprojBuilder) solutionPlatform(platformName string) string {
	switch platformName {
	case "Win32":
		return "Win32"
	case "Win64":
		return "x64"
	default:
		UnexpectedValue(platformName)
		return ""
	}
}
func (x *VcxprojBuilder) vcxconfig(bff *BffFile, u *Unit) BffVar {
	configVar := MakeBffVar(u.String())
	bff.Struct(configVar, func() {
		bff.Assign("Platform", x.solutionPlatform(u.Target.PlatformName))
		bff.Assign("Config", u.Target.ConfigName)
		bff.Assign("PlatformToolset", "v"+u.Facet.Exports.Get("VisualStudio/PlatformToolset"))
		bff.Assign("Output", u.OutputFile)
		bff.Assign("OutputDirectory", UFS.Binaries)
		bff.Assign("IntermediateDirectory", u.IntermediateDir)
		bff.Assign("BuildLogFile", u.IntermediateDir.File("BuildLog.log"))
		bff.Assign("AdditionalOptions", u.AnalysisOptions.Join(" "))
		bff.Assign("PreprocessorDefinitions", u.Defines.Join(";"))
		bff.Assign("ForcedIncludes", u.ForceIncludes.StringSet().Join(";"))

		includeSearchPaths := NewDirSet(u.IncludePaths...)
		includeSearchPaths.Append(u.ExternIncludePaths...)
		includeSearchPaths.Append(u.SystemIncludePaths...)
		bff.Assign("IncludeSearchPath", includeSearchPaths.StringSet().Join(";"))

		if u.Payload.HasOutput() {
			target := u.Target.String()
			bff.Assign("ProjectBuildCommand", "$BaseProjectBuildCommand$ "+target)
			bff.Assign("ProjectRebuildCommand", "$BaseProjectRebuildCommand$ "+target)
			bff.Assign("ProjectCleanCommand", "$BaseProjectCleanCommand$ "+target)

			if u.Payload == PAYLOAD_EXECUTABLE {
				bff.Assign("LocalDebuggerCommand", u.OutputFile)
				bff.Assign("LocalDebuggerWorkingDirectory", u.OutputFile.Dirname)

				var htmlLineFeed = `&#10;`
				bff.Assign("LocalDebuggerEnvironment", strings.Join(append(u.Environment.Export(), "^$(LocalDebuggerEnvironment)"), htmlLineFeed))
			}
		}
	})
	return configVar
}
