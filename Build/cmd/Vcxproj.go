package cmd

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"io"
	"os"
)

type VcxprojArgsT struct{}

func (flags *VcxprojArgsT) InitFlags(cfg *PersistentMap) {
}
func (flags *VcxprojArgsT) ApplyVars(cfg *PersistentMap) {
}
func (flags *VcxprojArgsT) Alias() BuildAlias {
	return MakeBuildAlias("Flags", "VcxprojArgs")
}
func (flags *VcxprojArgsT) Build(BuildContext) (BuildStamp, error) {
	return MakeBuildStamp(flags)
}
func (flags *VcxprojArgsT) GetDigestable(o *bytes.Buffer) {
}

var VcxprojArgs = MakeServiceAccessor[ParsableFlags](newVcxprojArgs)

func newVcxprojArgs() *VcxprojArgsT {
	return CommandEnv.BuildGraph().Create(&VcxprojArgsT{}).GetBuildable().(*VcxprojArgsT)
}

var Vcxproj = MakeCommand(
	"vcxproj",
	"generate projects and solution for Visual Studio",
	func(cmd *CommandEnvT) *VcxprojArgsT {
		AllCompilationFlags.Needed(cmd.Flags)
		return VcxprojArgs.FindOrAdd(cmd.Flags)
	},
	func(cmd *CommandEnvT, args *VcxprojArgsT) error {
		bg := cmd.BuildGraph()
		builder := bg.Create(&VcxprojBuilder{
			Output: UFS.Output.File("vcxproj.bff"),
		}, args.Alias())

		vcx := builder.GetBuildable().(*VcxprojBuilder)

		LogClaim("generating VCXProj solution in '%v'", vcx.SolutionFile())

		_, result := bg.Build(builder)
		if err := result.Join().Failure(); err != nil {
			return err
		}

		fbuildArgs := FBuildArgs{
			BffInput: vcx.Output,
		}

		fbuildExec := MakeFBuildExecutor(&fbuildArgs)
		fbuildExec.Capture = false

		return fbuildExec.Run()
	},
)

/***************************************
 * VCXProj/SLN generation
 ***************************************/

type VcxProject struct {
	ModuleDir     Directory
	Aliases       BffArray
	InputPaths    DirSet
	SourceFiles   FileSet
	SourceGlobs   StringSet
	ExcludedFiles FileSet
	ShouldBuild   bool
}

type VcxprojBuilder struct {
	Output       Filename
	environments SetT[EnvironmentAlias]
	projects     map[ModuleAlias]*VcxProject
}

func (vcx *VcxprojBuilder) Alias() BuildAlias {
	return MakeBuildAlias("Vcxproj", vcx.Output.String())
}
func (vcx *VcxprojBuilder) SolutionFile() Filename {
	return UFS.Output.File(CommandEnv.Prefix() + ".sln")
}
func (vcx *VcxprojBuilder) Build(bc BuildContext) (BuildStamp, error) {
	modules := BuildModules.Need(bc)
	targets := BuildTargets.Need(bc)
	bc.DependsOn(modules, targets)

	translatedUnits := targets.TranslatedUnits()

	vcx.environments = NewSet[EnvironmentAlias]()
	vcx.projects = make(map[ModuleAlias]*VcxProject, translatedUnits.Len())

	err := UFS.SafeCreate(vcx.Output, func(wr io.Writer) error {
		bff := NewBffFile(wr, false)
		bff.Comment("BFF generated by %v", MAIN_SIGNATURE)

		selfExecutable, err := os.Executable()
		if err != nil {
			LogPanicErr(err)
		}

		bff.Assign("BaseProjectBuildCommand", selfExecutable+" fbuild -Ide ")
		bff.Assign("BaseProjectRebuildCommand", selfExecutable+" fbuild -Ide -Clean ")
		bff.Assign("BaseProjectCleanCommand", selfExecutable+" distclean -Ide ")

		bff.Assign("ProjectPatternToExclude", NewStringSet(
			"*/.vs/*",
			"*/.vscode/*"))

		for _, unit := range translatedUnits.Slice() {
			configVar := vcx.vcxconfig(bff, unit)

			inputPaths := unit.Source.SourceDirs.Concat(unit.Source.ExtraDirs...)
			publicDir := unit.ModuleDir.Folder("Public")
			if publicDir.Exists() {
				inputPaths.Append(publicDir)
			}

			sourceFiles := unit.Source.ExtraFiles.
				ConcatUniq(unit.Source.IsolatedFiles...).
				ConcatUniq(unit.Source.SourceFiles...).
				ConcatUniq(unit.ForceIncludes...)

			if unit.PCH != PCH_DISABLED {
				sourceFiles.AppendUniq(unit.PrecompiledHeader)
				sourceFiles.AppendUniq(unit.PrecompiledSource)
			}

			if gitignore := unit.ModuleDir.File(".gitignore"); gitignore.Exists() {
				sourceFiles.AppendUniq(gitignore)
			}

			project, ok := vcx.projects[unit.Target.ModuleAlias]
			if !ok {
				project = &VcxProject{
					ModuleDir:     unit.ModuleDir,
					Aliases:       BffArray{},
					InputPaths:    NewDirSet(),
					SourceFiles:   NewFileSet(),
					SourceGlobs:   NewStringSet(),
					ExcludedFiles: NewFileSet(),
					ShouldBuild:   false,
				}
				vcx.projects[unit.Target.ModuleAlias] = project
			}
			Assert(func() bool { return project.ModuleDir.Equals(unit.ModuleDir) })

			project.Aliases = append(project.Aliases, configVar)
			project.InputPaths.AppendUniq(inputPaths...)
			project.SourceFiles.AppendUniq(sourceFiles...)
			project.SourceGlobs.AppendUniq(unit.Source.SourceGlobs...)
			project.ExcludedFiles.AppendUniq(unit.Source.ExcludedFiles...)
			project.ShouldBuild = project.ShouldBuild || unit.Payload != PAYLOAD_HEADERS

			vcx.environments.AppendUniq(unit.Target.EnvironmentAlias)
		}

		buildProjects := NewStringSet()
		solutionFolders := make(map[string]*StringSet, translatedUnits.Len())
		for module, project := range vcx.projects {
			relativePath := project.ModuleDir.Relative(UFS.Source)

			moduleId := SanitizeIdentifier(relativePath)
			outputDir := UFS.Projects.AbsoluteFolder(relativePath)

			moduleVcxprojet := moduleId + "-vcxproject"
			bff.Func("VCXProject", func() {
				bff.Assign("ProjectBasePath", project.ModuleDir)
				bff.Assign("ProjectOutput", outputDir.String()+".vcxproj")
				bff.Assign("ProjectConfigs", project.Aliases)
				bff.Assign("ProjectInputPaths", project.InputPaths)
				bff.Assign("ProjectAllowedFileExtensions",
					NewStringSet(append(project.SourceGlobs, "*.h", "*.rc")...))
				bff.Assign("ProjectFiles", project.SourceFiles)
				bff.Assign("ProjectFilesToExclude", project.ExcludedFiles)
			}, moduleVcxprojet)

			if list, ok := solutionFolders[module.NamespaceName]; ok {
				list.Append(moduleVcxprojet)
			} else {
				list := NewStringSet(moduleVcxprojet)
				solutionFolders[module.NamespaceName] = &list
			}

			if project.ShouldBuild {
				buildProjects.Append(moduleVcxprojet)
			}
		}

		{ // meta project for build inspection/regen/natvis
			moduleVcxprojet := "BuildConfig-vcxproject"
			buildProjects.Append(moduleVcxprojet)
			solutionFolders["Build"] = &StringSet{moduleVcxprojet}

			bff.Func("VCXProject", func() {
				sourceFiles := NewFileSet( // #TODO: this is very project specific
					BFFFILE_DEFAULT,
					vcx.Output,
					UFS.Root.File("PPE.go"),
					UFS.Root.File("README.md"),
					UFS.Root.File("TODO.md"),
					UFS.Source.File("cpp.hint"),
					UFS.Source.File(".gitignore"),
					UFS.Source.File("winnt_version.h"),
					UFS.Extras.Folder("Debug").File("PPE.natvis"))

				bff.Assign("ProjectBuildCommand", selfExecutable+" bff -v -and vcxproj -and vscode")
				bff.Assign("ProjectRebuildCommand", selfExecutable+" bff -v -f -and vcxproj -and vscode")
				bff.Assign("ProjectCleanCommand", selfExecutable+" distclean -v -F")

				configVars := BffArray{}
				for _, env := range vcx.environments.Slice() {
					configVar := MakeBffVar("BuildConfig-" + env.Alias().String())
					bff.Struct(configVar, func() {
						bff.Assign("Platform", vcx.solutionPlatform(env.PlatformName))
						bff.Assign("Config", env.ConfigName)
					})
					configVars = append(configVars, configVar)
				}

				bff.Assign("ProjectBasePath", UFS.Root)
				bff.Assign("ProjectOutput", UFS.Projects.AbsoluteFolder("BuildConfig").String()+".vcxproj")
				bff.Assign("ProjectConfigs", configVars)
				bff.Assign("ProjectInputPaths", NewDirSet(UFS.Build, UFS.Source))
				bff.Assign("ProjectAllowedFileExtensions", NewStringSet("*.go", "*.bff", "*.json", "*.exe"))
				bff.Assign("ProjectFiles", sourceFiles)
			}, moduleVcxprojet)
		}

		bff.Func("VSSolution", func() {
			bff.Assign("SolutionVisualStudioVersion", "16") // #TODO: not hard-coding visual studio version
			bff.Assign("SolutionOutput", vcx.SolutionFile())
			bff.Assign("SolutionBuildProject", buildProjects)
			bff.Assign("SolutionConfigs", MakeBffArray(Map(func(a EnvironmentAlias) interface{} {
				result := MakeBffVar(a.GetEnvironmentAlias().String())
				bff.Struct(result, func() {
					bff.Assign("Platform", vcx.solutionPlatform(a.PlatformName))
					bff.Assign("Config", a.ConfigName)
				})
				return result
			}, vcx.environments.Slice()...)...))
			bff.Assign("SolutionFolders", MakeBffArray(Map(func(namespace string) BffVar {
				result := MakeBffVar("Folder_" + namespace)
				bff.Struct(result, func() {
					bff.Assign("Path", namespace)
					bff.Assign("Projects", solutionFolders[namespace])
				})
				return result
			}, Keys(solutionFolders)...)...))

			hasVcxproject := false
			for _, moduleVcxprojects := range solutionFolders {
				if moduleVcxprojects.Len() > 0 {
					if hasVcxproject {
						bff.Append("SolutionProjects", moduleVcxprojects)
					} else {
						hasVcxproject = true
						bff.Assign("SolutionProjects", moduleVcxprojects)
					}
				}
			}
		}, "all")

		return nil
	})

	if err == nil {
		bc.OutputFile(vcx.Output)
		return vcx.Output.Build(bc)
	} else {
		return BuildStamp{}, err
	}
}

func (x *VcxprojBuilder) solutionPlatform(platformName string) string {
	switch platformName {
	case "Win32":
		return "Win32"
	case "Win64":
		return "x64"
	default:
		UnexpectedValue(platformName)
		return ""
	}
}
func (x *VcxprojBuilder) vcxconfig(bff *BffFile, u *Unit) BffVar {
	configVar := MakeBffVar(u.String())
	bff.Struct(configVar, func() {
		bff.Assign("Platform", x.solutionPlatform(u.Target.PlatformName))
		bff.Assign("Config", u.Target.ConfigName)
		bff.Assign("PlatformToolset", "v"+u.Facet.Exports.Get("VisualStudio/PlatformToolset"))
		bff.Assign("Output", u.OutputFile)
		bff.Assign("OutputDirectory", UFS.Binaries)
		bff.Assign("IntermediateDirectory", u.IntermediateDir)
		bff.Assign("BuildLogFile", u.IntermediateDir.File("BuildLog.log"))
		bff.Assign("AdditionalOptions", u.AnalysisOptions.Join(" "))
		bff.Assign("PreprocessorDefinitions", u.Defines.Join(";"))
		bff.Assign("ForcedIncludes", u.ForceIncludes.StringSet().Join(";"))

		includeSearchPaths := NewDirSet(u.IncludePaths...)
		includeSearchPaths.Append(u.ExternIncludePaths...)
		includeSearchPaths.Append(u.SystemIncludePaths...)
		bff.Assign("IncludeSearchPath", includeSearchPaths.StringSet().Join(";"))

		if u.Payload.HasOutput() {
			target := u.Target.String()
			bff.Assign("ProjectBuildCommand", "$BaseProjectBuildCommand$ "+target)
			bff.Assign("ProjectRebuildCommand", "$BaseProjectRebuildCommand$ "+target)
			bff.Assign("ProjectCleanCommand", "$BaseProjectCleanCommand$ "+target)

			if u.Payload == PAYLOAD_EXECUTABLE {
				bff.Assign("LocalDebuggerCommand", u.OutputFile)
				bff.Assign("LocalDebuggerWorkingDirectory", u.OutputFile.Dirname)
				bff.Assign("LocalDebuggerEnvironment", "PATH="+u.Compiler.EnvPath().Join(";")+";%PATH%&#xA;^$(LocalDebuggerEnvironment)")
			}
		}
	})
	return configVar
}
