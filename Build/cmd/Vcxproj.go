package cmd

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"io"
	"os"
)

type VcxprojArgsT struct{}

func (flags *VcxprojArgsT) InitFlags(cfg *PersistentMap) {
}
func (flags *VcxprojArgsT) ApplyVars(cfg *PersistentMap) {
}
func (flags *VcxprojArgsT) Alias() BuildAlias {
	return MakeBuildAlias("Flags", "VcxprojArgs")
}
func (flags *VcxprojArgsT) Build(BuildContext) (BuildStamp, error) {
	return MakeBuildStamp(flags)
}
func (flags *VcxprojArgsT) GetDigestable(o *bytes.Buffer) {
}

var VcxprojArgs = MakeServiceAccessor[ParsableFlags](newVcxprojArgs)

func newVcxprojArgs() *VcxprojArgsT {
	return CommandEnv.BuildGraph().Create(&VcxprojArgsT{}).GetBuildable().(*VcxprojArgsT)
}

var Vcxproj = MakeCommand(
	"vcxproj",
	"generate projects and solution for Visual Studio",
	func(cmd *CommandEnvT) *VcxprojArgsT {
		AllCompilationFlags.Needed(cmd.Flags)
		return VcxprojArgs.FindOrAdd(cmd.Flags)
	},
	func(cmd *CommandEnvT, args *VcxprojArgsT) error {
		output := UFS.Output.File("vcxproj.bff")
		LogClaim("generating VCXProj config in '%v'", output)

		bg := cmd.BuildGraph()
		builder := bg.Create(&VcxprojBuilder{
			Output: output,
		}, args.Alias())

		_, result := bg.Build(builder)
		if err := result.Join().Failure(); err != nil {
			return err
		}

		fbuildArgs := FBuildArgs{
			BffInput: output,
		}

		fbuildExec := MakeFBuildExecutor(&fbuildArgs)
		fbuildExec.Capture = false

		return fbuildExec.Run()
	},
)

/***************************************
 * VCXProj/SLN generation
 ***************************************/

type VcxprojBuilder struct {
	Output Filename
}

func (vcx *VcxprojBuilder) Alias() BuildAlias {
	return vcx.Output.Alias()
}
func (vcx *VcxprojBuilder) Build(bc BuildContext) (BuildStamp, error) {
	args := VcxprojArgs.Need(CommandEnv.Flags)
	modules := BuildModules.Need(bc)
	targets := BuildTargets.Need(bc)
	bc.DependsOn(args, modules, targets)

	translatedUnits := targets.TranslatedUnits()

	moduleGraph := GetModuleGraph(modules)
	moduleGraph.Keys()

	err := UFS.SafeCreate(vcx.Output, func(wr io.Writer) error {
		bff := NewBffFile(wr, false)
		bff.Comment("BFF generated by %v", MAIN_SIGNATURE)

		selfExecutable, err := os.Executable()
		if err != nil {
			panic(err)
		}

		bff.Assign("BaseProjectBuildCommand", selfExecutable+" fbuild -v ")
		bff.Assign("BaseProjectRebuildCommand", selfExecutable+" fbuild -v -Clean ")
		bff.Assign("BaseProjectCleanCommand", selfExecutable+" distclean -v ")

		bff.Assign("ProjectPatternToExclude", NewStringSet(
			"*/.vs/*",
			"*/.vscode/*"))

		compileEnvs := NewSet[EnvironmentAlias]()
		moduleUnits := make(map[Module]*BffArray, translatedUnits.Len())
		for _, x := range translatedUnits.Slice() {
			configVar := vcx.vcxconfig(bff, x)
			module := moduleGraph.Module(x.Target.GetModuleAlias())

			if arr, ok := moduleUnits[module]; ok {
				*arr = append(*arr, configVar)
			} else {
				arr := MakeBffArray(configVar)
				moduleUnits[module] = &arr
			}

			compileEnvs.AppendUniq(x.Target.EnvironmentAlias)
		}

		buildProjects := NewStringSet()
		solutionFolders := make(map[string]*StringSet, translatedUnits.Len())
		for module, configVars := range moduleUnits {
			moduleRules := module.GetModule()
			relativePath := moduleRules.ModuleDir.Relative(UFS.Source)

			moduleId := SanitizeIdentifier(relativePath)
			outputDir := UFS.Projects.AbsoluteFolder(relativePath)

			moduleVcxprojet := moduleId + "-vcxproject"
			bff.Func("VCXProject", func() {
				inputPaths := moduleRules.Source.SourceDirs.Concat(moduleRules.Source.ExtraDirs...)
				if moduleRules.PublicDir().Exists() {
					inputPaths.Append(moduleRules.PublicDir())
				}

				sourceFiles := moduleRules.Source.ExtraFiles.
					ConcatUniq(moduleRules.ForceIncludes...).
					ConcatUniq(moduleRules.Source.IsolatedFiles...).
					ConcatUniq(moduleRules.Source.SourceFiles...)
				if moduleRules.PrecompiledHeader != nil {
					sourceFiles.AppendUniq(*moduleRules.PrecompiledHeader)
				}
				if moduleRules.PrecompiledSource != nil {
					sourceFiles.AppendUniq(*moduleRules.PrecompiledSource)
				}

				bff.Assign("ProjectBasePath", moduleRules.ModuleDir)
				bff.Assign("ProjectOutput", outputDir.String()+".vcxproj")
				bff.Assign("ProjectConfigs", *configVars)
				bff.Assign("ProjectInputPaths", inputPaths)
				bff.Assign("ProjectAllowedFileExtensions",
					NewStringSet(append(moduleRules.Source.SourceGlobs, "*.h", "*.rc")...))
				bff.Assign("ProjectFiles", sourceFiles)
				bff.Assign("ProjectFilesToExclude", moduleRules.Source.ExcludedFiles)
			}, moduleVcxprojet)

			if list, ok := solutionFolders[module.GetNamespace().String()]; ok {
				list.Append(moduleVcxprojet)
			} else {
				list := NewStringSet(moduleVcxprojet)
				solutionFolders[module.GetNamespace().String()] = &list
			}

			if moduleRules.ModuleType != MODULE_HEADERS {
				buildProjects.Append(moduleVcxprojet)
			}
		}

		{ // meta project for build inspection/regen/natvis
			moduleVcxprojet := "BuildConfig-vcxproject"
			buildProjects.Append(moduleVcxprojet)
			solutionFolders["Build"] = &StringSet{moduleVcxprojet}

			bff.Func("VCXProject", func() {
				sourceFiles := NewFileSet( // #TODO: this is very project specific
					BFFFILE_DEFAULT,
					vcx.Output,
					UFS.Root.File("PPE.go"),
					UFS.Root.File("README.md"),
					UFS.Root.File("TODO.md"),
					UFS.Extras.Folder("Debug").File("PPE.natvis"))

				bff.Assign("ProjectBuildCommand", selfExecutable+" bff -v -and vcxproj -and vscode")
				bff.Assign("ProjectRebuildCommand", selfExecutable+" bff -v -f -and vcxproj -and vscode")
				bff.Assign("ProjectCleanCommand", selfExecutable+" distclean -v -F")

				configVars := BffArray{}
				for _, env := range compileEnvs {
					configVar := MakeBffVar("BuildConfig-" + env.Alias().String())
					bff.Struct(configVar, func() {
						bff.Assign("Platform", vcx.solutionPlatform(env.PlatformName))
						bff.Assign("Config", env.ConfigName)
					})
					configVars = append(configVars, configVar)
				}

				bff.Assign("ProjectBasePath", UFS.Root)
				bff.Assign("ProjectOutput", UFS.Projects.AbsoluteFolder("BuildConfig").String()+".vcxproj")
				bff.Assign("ProjectConfigs", configVars)
				bff.Assign("ProjectInputPaths", NewDirSet(UFS.Build, UFS.Source))
				bff.Assign("ProjectAllowedFileExtensions", NewStringSet("*.go", "*.bff", "*.json", "*.exe"))
				bff.Assign("ProjectFiles", sourceFiles)
			}, moduleVcxprojet)
		}

		bff.Func("VSSolution", func() {
			bff.Assign("SolutionVisualStudioVersion", "16") // #TODO: not hard-coding visual studio version
			bff.Assign("SolutionOutput", UFS.Output.File(CommandEnv.Prefix()+".sln"))
			bff.Assign("SolutionBuildProject", buildProjects)
			bff.Assign("SolutionConfigs", MakeBffArray(Map(func(a EnvironmentAlias) interface{} {
				result := MakeBffVar(a.GetEnvironmentAlias().String())
				bff.Struct(result, func() {
					bff.Assign("Platform", vcx.solutionPlatform(a.PlatformName))
					bff.Assign("Config", a.ConfigName)
				})
				return result
			}, compileEnvs...)...))
			bff.Assign("SolutionFolders", MakeBffArray(Map(func(namespace string) BffVar {
				result := MakeBffVar("Folder_" + namespace)
				bff.Struct(result, func() {
					bff.Assign("Path", namespace)
					bff.Assign("Projects", solutionFolders[namespace])
				})
				return result
			}, Keys(solutionFolders)...)...))

			hasVcxproject := false
			for _, moduleVcxprojects := range solutionFolders {
				if moduleVcxprojects.Len() > 0 {
					if hasVcxproject {
						bff.Append("SolutionProjects", moduleVcxprojects)
					} else {
						hasVcxproject = true
						bff.Assign("SolutionProjects", moduleVcxprojects)
					}
				}
			}
		}, "all")

		return nil
	})

	if err == nil {
		return vcx.Output.Build(bc)
	} else {
		return BuildStamp{}, err
	}
}

func (x *VcxprojBuilder) solutionPlatform(platformName string) string {
	switch platformName {
	case "Win32":
		return "Win32"
	case "Win64":
		return "x64"
	default:
		UnexpectedValue(platformName)
		return ""
	}
}
func (x *VcxprojBuilder) vcxconfig(bff *BffFile, u *Unit) BffVar {
	configVar := MakeBffVar(u.String())
	bff.Struct(configVar, func() {
		bff.Assign("Platform", x.solutionPlatform(u.Target.PlatformName))
		bff.Assign("Config", u.Target.ConfigName)
		bff.Assign("PlatformToolset", "v"+u.Facet.Exports.Get("VisualStudio/PlatformToolset"))
		bff.Assign("Output", u.OutputFile)
		bff.Assign("OutputDirectory", UFS.Binaries)
		bff.Assign("IntermediateDirectory", u.IntermediateDir)
		bff.Assign("BuildLogFile", u.IntermediateDir.File("BuildLog.log"))
		bff.Assign("AdditionalOptions", u.AnalysisOptions.Join(" "))
		bff.Assign("PreprocessorDefinitions", u.Defines.Join(";"))
		bff.Assign("ForcedIncludes", u.ForceIncludes.StringSet().Join(";"))

		includeSearchPaths := NewDirSet(u.IncludePaths...)
		includeSearchPaths.Append(u.ExternIncludePaths...)
		includeSearchPaths.Append(u.SystemIncludePaths...)
		bff.Assign("IncludeSearchPath", includeSearchPaths.StringSet().Join(";"))

		if u.Payload.HasOutput() {
			target := u.Target.String()
			bff.Assign("ProjectBuildCommand", "$BaseProjectBuildCommand$ "+target)
			bff.Assign("ProjectRebuildCommand", "$BaseProjectRebuildCommand$ "+target)
			bff.Assign("ProjectCleanCommand", "$BaseProjectCleanCommand$ "+target)

			if u.Payload == PAYLOAD_EXECUTABLE {
				bff.Assign("LocalDebuggerCommand", u.OutputFile)
				bff.Assign("LocalDebuggerWorkingDirectory", u.OutputFile.Dirname)
				bff.Assign("LocalDebuggerEnvironment", "PATH="+u.Compiler.EnvPath().Join(";")+";%PATH%&#xA;^$(LocalDebuggerEnvironment)")
			}
		}
	})
	return configVar
}
