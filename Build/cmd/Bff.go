package cmd

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"fmt"
	"io"
	"sort"
)

const BFF_VERSION = "0.8"

var BFFFILE_DEFAULT = UFS.Output.File("fbuild.bff")

type BffArgsT struct {
	BffOutput           Filename
	DeoptimizeWithToken BoolVar
	LightCache          BoolVar
	Minify              BoolVar
	RelativePaths       BoolVar
	Clean               BoolVar
}

func (flags *BffArgsT) InitFlags(cfg *PersistentMap) {
	cfg.Persistent(&flags.BffOutput, "BffOutput", "destination for generated FASTBuild config file (*.bff)")
	cfg.Persistent(&flags.DeoptimizeWithToken, "DeoptimizeWithToken", "enable/disable compiler optimization with FASTBUILD_DEOPTIMIZE_OBJECT")
	cfg.Persistent(&flags.LightCache, "LightCache", "enable/disable FASTBuild lightweight parsing for caching")
	cfg.Persistent(&flags.Minify, "Minify", "enable/disable pretty print for generated FASTBuild file")
	cfg.Persistent(&flags.RelativePaths, "RelativePaths", "enable/disable FASTBuild relative paths for caching")
	cfg.Var(&flags.Clean, "Clean", "invalidate and regenerate BFF file")
}
func (flags *BffArgsT) ApplyVars(cfg *PersistentMap) {
}

func (flags *BffArgsT) Alias() BuildAlias {
	return MakeBuildAlias("Flags", "BffArgs")
}
func (flags *BffArgsT) Build(BuildContext) (BuildStamp, error) {
	return MakeBuildStamp(flags)
}
func (flags *BffArgsT) GetDigestable(o *bytes.Buffer) {
	flags.BffOutput.GetDigestable(o)
	flags.DeoptimizeWithToken.GetDigestable(o)
	flags.LightCache.GetDigestable(o)
	flags.Minify.GetDigestable(o)
	flags.RelativePaths.GetDigestable(o)
}

var BffArgs = MakeServiceAccessor[ParsableFlags](newBffArgs)

func newBffArgs() *BffArgsT {
	return CommandEnv.BuildGraph().Create(&BffArgsT{
		BffOutput:           BFFFILE_DEFAULT,
		DeoptimizeWithToken: INHERITABLE_FALSE,
		LightCache:          INHERITABLE_FALSE,
		Minify:              INHERITABLE_TRUE,
		RelativePaths:       INHERITABLE_FALSE,
	}).GetBuildable().(*BffArgsT)
}

var Bff = MakeCommand(
	"bff",
	"generate FASTBuild config file",
	func(cmd *CommandEnvT) *BffArgsT {
		AllCompilationFlags.Needed(cmd.Flags)
		return BffArgs.FindOrAdd(cmd.Flags)
	},
	func(cmd *CommandEnvT, args *BffArgsT) error {
		LogClaim("generating BFF config in '%v'", args.BffOutput)

		bg := cmd.BuildGraph()
		builder := bg.Create(&BffBuilder{
			Output:  args.BffOutput,
			Version: BFF_VERSION,
		}, args.Alias())

		var result Future[BuildStamp]
		if args.Clean.Get() {
			_, result = bg.ForceBuild(builder.GetBuildable())
		} else {
			_, result = bg.Build(builder)
		}

		return result.Join().Failure()
	},
)

/***************************************
 * FASTBuild config generation
 ***************************************/

type BffBuilder struct {
	Output  Filename
	Version string
}

func (x *BffBuilder) Alias() BuildAlias {
	return MakeBuildAlias("Bff", x.Output.String())
}
func (x *BffBuilder) GetDigestable(o *bytes.Buffer) {
	o.WriteString(x.Output.String())
	o.WriteByte(0)
	o.WriteString(x.Version)
}
func (x *BffBuilder) Build(bc BuildContext) (BuildStamp, error) {
	sourceControlModifiedFiles := GenerateSourceControlModifiedFiles()
	targets := BuildTargets.Need(bc)
	args := BffArgs.FindOrAdd(CommandEnv.Flags)

	err := UFS.LazyCreate(x.Output, func(dst io.Writer) error {

		bff := newBffGenerator(dst, args)

		bff.Comment("BFF generated by %v", MAIN_SIGNATURE)
		bff.Func("Settings", func() {
			bff.Assign("RootPath", UFS.Root)
			bff.Assign("CachePath", UFS.Cache)
			if CurrentHost().Id == HOST_WINDOWS {
				platform := BuildPlatforms.Need(bc).Current()
				compiler := platform.GetCompiler(bc)

				path := JoinString(";", compiler.EnvPath()...)
				bff.Import("TMP")
				bff.Assign("Environment", BffArray{
					"PATH=" + path,
					"TMP=$TMP$",
					"SystemRoot=C:\\Windows",
				})
			}
		})

		bff.Comment("Global invariants")
		bff.Assign("CompilerOutputKeepBaseExtension", false)
		bff.Assign("DeoptimizeWritableFilesWithToken", args.DeoptimizeWithToken)
		bff.Assign("LinkerVerboseOutput", true)
		bff.Assign("UnityInputIsolateListFile", sourceControlModifiedFiles.Join().Success())

		translatedUnits := targets.TranslatedUnits()
		for _, unit := range translatedUnits.Slice() {
			bff.Comment("Target %v", unit.Target)
			switch unit.Payload {
			case PAYLOAD_EXECUTABLE:
				bff.Executable(unit)
			case PAYLOAD_HEADERS:
				bff.Headers(unit)
			case PAYLOAD_OBJECTLIST:
				bff.ObjectList(unit)
			case PAYLOAD_SHAREDLIB:
				bff.SharedLib(unit)
			case PAYLOAD_STATICLIB:
				bff.StaticLib(unit)
			default:
				UnexpectedValuePanic(unit.Payload, unit.Payload)
			}
		}

		bff.MakeAliases(translatedUnits.Slice())

		return nil
	})

	if err == nil {
		bc.OutputFile(x.Output)
		return MakeBuildStamp(x)
	} else {
		return BuildStamp{}, err
	}
}

type bffGenerator struct {
	*BffArgsT
	*BffFile
}

func newBffGenerator(dst io.Writer, args *BffArgsT) (result bffGenerator) {
	result = bffGenerator{
		BffArgsT: args,
		BffFile:  NewBffFile(dst, args.Minify.Get()),
	}
	return result
}

func (gen bffGenerator) Executable(unit *Unit) {
	gen.BaseDeliverable(unit, true)
}
func (gen bffGenerator) Headers(unit *Unit) {
	gen.Func("Alias", func() {
		fileset := FileSet{}
		fileset.Append(unit.Source.ExtraFiles...)
		fileset.Append(unit.Libraries...)
		gen.Assign("Targets", fileset)
	}, unit.Target.String())
}
func (gen bffGenerator) ObjectList(unit *Unit) {
	gen.BaseModule(unit, "", true)
}
func (gen bffGenerator) SharedLib(unit *Unit) {
	gen.BaseDeliverable(unit, false)
}
func (gen bffGenerator) StaticLib(unit *Unit) {
	gen.BaseModule(unit, "", false)
}
func (gen bffGenerator) BaseDeliverable(unit *Unit, executable bool) {
	libraries := []string{gen.BaseModule(unit, "-Obj", true)}
	libraries = append(libraries, Stringize(unit.CompileDependencies.Slice()...)...)
	libraries = append(libraries, Stringize(unit.LinkDependencies.Slice()...)...)
	libraries = append(libraries, gen.CustomUnits(unit)...)

	compilerDetails := gen.Compiler(unit.Compiler)

	funcName := "DLL"
	if executable {
		funcName = "Executable"
	}

	gen.Func(funcName, func() {
		gen.Using(compilerDetails)
		gen.Assign("Libraries", MakeBffArray(libraries...))
		gen.Assign("LinkerOptions", unit.LinkerOptions.Join(" "))
		gen.Assign("LinkerOutput", unit.OutputFile)
		gen.Assign("PreBuildDependencies", Stringize(unit.RuntimeDependencies.Slice()...))
	}, unit.Target.String())
}
func (gen bffGenerator) BaseModule(unit *Unit, suffix string, linkLibraryObjects bool) string {
	compilerDetails := gen.Compiler(unit.Compiler)

	var preprocessorDetails BffVar
	if unit.Preprocessor != nil {
		preprocessorDetails = gen.Compiler(unit.Preprocessor)
	}

	UFS.Mkdir(UFS.Transient)

	moduleSource := MakeBffVar(unit.Target.GetModuleAlias().String() + "_Source_" + unit.PCH.String() + "_" + unit.Unity.String())
	gen.Once(moduleSource, func() {
		gen.Comment("Target source details for %v", unit)

		var moduleUnity string
		if unit.Unity.Ord() > 0 {
			moduleUnity = (unit.Target.GetModuleAlias().String() + "-Unity-PCH_" + unit.PCH.String())

			gen.Once(BffVar(moduleUnity), func() {
				gen.Func("Unity", func() {
					gen.Assign("Hidden", true)
					gen.Assign("UnityNumFiles", unit.Unity.Ord())
					gen.Assign("UnityInputFiles", unit.Source.SourceFiles)
					gen.Assign("UnityInputPath", unit.Source.SourceDirs)
					gen.Assign("UnityInputPattern", unit.Source.SourceGlobs)
					gen.Assign("UnityInputExcludedFiles", unit.Source.ExcludedFiles)
					gen.Assign("UnityInputExcludePattern", unit.Source.ExcludedGlobs)
					gen.Assign("UnityInputIsolatedFiles", unit.Source.IsolatedFiles)
					gen.Assign("UnityOutputPath", unit.GeneratedDir)
					gen.Assign("UnityOutputPattern", fmt.Sprintf("%s_*_of_%d.cpp", unit.Target.ModuleName, unit.Unity.Ord()))
					if unit.PCH != PCH_DISABLED {
						gen.Assign("UnityPCH", unit.PrecompiledHeader.Basename)
					}
				}, moduleUnity)
			})
		}

		gen.Struct(moduleSource, func() {
			gen.Assign("CompilerInputFilesRoot", unit.ModuleDir)
			if moduleUnity != "" {
				gen.Assign("CompilerInputUnity", moduleUnity)
			} else {
				gen.Assign("CompilerInputFiles", unit.Source.SourceFiles)
				if unit.Source.SourceDirs.Len() > 0 {
					gen.Assign("CompilerInputPattern", unit.Source.SourceGlobs)
					gen.Assign("CompilerInputPath", unit.Source.SourceDirs)
					gen.Assign("CompilerInputPathRecurse", true)
				}
				gen.Assign("CompilerInputExcludedFiles", unit.Source.ExcludedFiles)
				gen.Assign("CompilerInputExcludePattern", unit.Source.ExcludedGlobs)
			}
			if unit.PCH == PCH_MONOLITHIC {
				gen.Assign("PCHInputFile", unit.PrecompiledSource)
			}
		})
	})

	artifactId := (unit.Target.String() + suffix)

	funcName := "Library"
	if linkLibraryObjects {
		funcName = "ObjectList"
	}

	gen.Func(funcName, func() {
		gen.Using(compilerDetails)
		gen.Using(moduleSource)

		if suffix != "" {
			gen.Assign("Hidden", true)
		}

		gen.Assign("CompilerOutputPath", unit.IntermediateDir)
		gen.Assign("CompilerOptions", unit.CompilerOptions.Join(" "))

		if unit.PCH == PCH_MONOLITHIC {
			gen.Assign("PCHOutputFile", unit.PrecompiledObject)
			gen.Assign("PCHOptions", unit.PrecompiledHeaderOptions.Join(" "))
		}

		if unit.Preprocessor != nil {
			gen.Assign("Preprocessor", preprocessorDetails)
			gen.Assign("PreprocessorOptions", unit.PreprocessorOptions.Join(" "))
		}

		if !linkLibraryObjects {
			compileDepAliases := Stringize(unit.CompileDependencies.Slice()...)
			compileDepAliases = append(compileDepAliases, gen.CustomUnits(unit)...)

			gen.Assign("LibrarianAdditionalInputs", compileDepAliases)
			gen.Assign("LibrarianOptions", unit.LibrarianOptions.Join(" "))
			gen.Assign("LibrarianOutput", unit.OutputFile)
		}

		includeDepAliases := Stringize(unit.IncludeDependencies.Slice()...)
		gen.Assign("PreBuildDependencies", includeDepAliases)

	}, artifactId)

	return artifactId
}
func (gen bffGenerator) Compiler(compiler Compiler) BffVar {
	rules := compiler.GetCompiler()
	details := MakeBffVar(rules.CompilerName + "_Details")
	gen.Once(details, func() {
		gen.Func("Compiler", func() {
			gen.Assign("CompilerFamily", rules.CompilerFamily)
			gen.Assign("Root", compiler.WorkingDir())
			gen.Assign("Executable", rules.Executable)
			gen.Assign("ExtraFiles", rules.ExtraFiles)
			gen.Assign("UseLightCache_Experimental", gen.LightCache)
			gen.Assign("UseRelativePaths_Experimental", gen.RelativePaths)
		}, rules.CompilerName)
		gen.Struct(details, func() {
			gen.Assign("Compiler", rules.CompilerName)
			gen.Assign("Librarian", rules.Librarian)
			gen.Assign("Linker", rules.Linker)
		})
	})
	return details
}
func (gen bffGenerator) CustomUnits(unit *Unit) []string {
	return Map(func(custom *CustomUnit) string {
		return gen.BaseModule(&custom.Unit, "", true)
	}, unit.CustomUnits...)
}
func (gen bffGenerator) MakeAliases(units []*Unit) {
	environments := NewCollector[BuildAlias, string]()
	namespaces := NewCollector[BuildAlias, string]()
	modules := NewCollector[BuildAlias, string]()

	for _, u := range units {
		target := u.Target
		alias := target.String()

		environments.Add(target.GetEnvironmentAlias(), alias)
		namespaces.Add(target.GetNamespaceAlias(), alias)
		modules.Add(target.GetModuleAlias(), alias)
	}

	for _, sorted := range []*Collector[BuildAlias, string]{environments, namespaces, modules} {
		sorted.Each(func(alias BuildAlias, list []string) {
			sort.Strings(list)
			gen.Func("Alias", func() {
				gen.Assign("Targets", list)
			}, alias.String())
		})
	}

	gen.Func("Alias", func() {
		names := Stringize(environments.Keys()...)
		sort.Strings(names)
		gen.Assign("Targets", names)
	}, "all")
}
