package cmd

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"fmt"
	"io"
)

const BFF_VERSION = "1.0.0"

var BFFFILE_DEFAULT = UFS.Output.File("fbuild.bff")

type BffArgsT struct {
	BffFile             Filename
	DeoptimizeWithToken BoolVar
	LightCache          BoolVar
	Minify              BoolVar
	RelativePaths       BoolVar
}

func (flags *BffArgsT) InitFlags(cfg *PersistentMap) {
	cfg.Persistent(&flags.BffFile, "BffFile", "destination for generated FASTBuild config file (*.bff)")
	cfg.Persistent(&flags.DeoptimizeWithToken, "DeoptimizeWithToken", "enable/disable compiler optimization with FASTBUILD_DEOPTIMIZE_OBJECT")
	cfg.Persistent(&flags.LightCache, "LightCache", "enable/disable FASTBuild lightweight parsing for caching")
	cfg.Persistent(&flags.Minify, "Minify", "enable/disable pretty print for generated FASTBuild file")
	cfg.Persistent(&flags.RelativePaths, "RelativePaths", "enable/disable FASTBuild relative paths for caching")
}
func (flags *BffArgsT) ApplyVars(cfg *PersistentMap) {
}

func (flags *BffArgsT) Alias() BuildAlias {
	return MakeBuildAlias("Flags", "BffArgs")
}
func (flags *BffArgsT) Build(BuildContext) (BuildStamp, error) {
	return MakeBuildStamp(flags)
}
func (flags *BffArgsT) GetDigestable(o *bytes.Buffer) {
	flags.BffFile.GetDigestable(o)
	flags.DeoptimizeWithToken.GetDigestable(o)
	flags.LightCache.GetDigestable(o)
	flags.Minify.GetDigestable(o)
	flags.RelativePaths.GetDigestable(o)
}

var BffArgs = MakeServiceAccessor[ParsableFlags](newBffArgs)

func newBffArgs() *BffArgsT {
	return CommandEnv.BuildGraph().Create(&BffArgsT{
		BffFile:             BFFFILE_DEFAULT,
		DeoptimizeWithToken: false,
		LightCache:          false,
		Minify:              true,
		RelativePaths:       false,
	}).GetBuildable().(*BffArgsT)
}

var Bff = MakeCommand(
	"bff",
	"generate FASTBuild config file",
	func(cmd *CommandEnvT) *BffArgsT {
		AllCompilationFlags.Needed(cmd.Flags)
		return BffArgs.Create(cmd.Flags)
	},
	func(cmd *CommandEnvT, args *BffArgsT) error {
		LogClaim("generating BFF config in '%v'", args.BffFile)

		bg := cmd.BuildGraph()
		builder := bg.Create(&BffBuilder{
			Output: args.BffFile,
		}, args.Alias())

		_, result := bg.Build(builder)
		return result.Join().Failure()
	},
)

/***************************************
 * FASTBuild config generation
 ***************************************/

type BffBuilder struct {
	Output Filename
}

func (x *BffBuilder) Alias() BuildAlias {
	return x.Output.Alias()
}
func (x *BffBuilder) Build(bc BuildContext) (BuildStamp, error) {
	sourceControlModifiedFiles := GenerateSourceControlModifiedFiles()
	targets := BuildTargets.Need(bc)

	err := UFS.SafeCreate(x.Output, func(dst io.Writer) error {
		args := BffArgs.Need(CommandEnv.Flags)
		bff := newBffGenerator(dst, args)

		bff.Comment("BFF generated by %v", MAIN_SIGNATURE)
		bff.Func("Settings", func() {
			bff.Assign("RootPath", UFS.Root)
			bff.Assign("CachePath", UFS.Cache)
			if CurrentHost().Id == HOST_WINDOWS {
				platform := BuildPlatforms.Need(bc).Current()
				compiler := platform.GetCompiler(bc)

				path := JoinString(";", compiler.EnvPath()...)
				bff.Import("TMP")
				bff.Assign("Environment", BffArray{
					"PATH=" + path,
					"TMP=$TMP$",
					"SystemRoot=C:\\Windows",
				})
			}
		})

		bff.Comment("Global invariants")
		bff.Assign("CompilerOutputKeepBaseExtension", false)
		bff.Assign("DeoptimizeWritableFilesWithToken", args.DeoptimizeWithToken)
		bff.Assign("LinkerVerboseOutput", true)
		bff.Assign("UnityInputIsolateListFile", sourceControlModifiedFiles.Join().Success())

		translatedUnits := targets.TranslatedUnits()
		for _, unit := range translatedUnits.Slice() {
			bff.Comment("Target %v", unit.Target)
			switch unit.Payload {
			case PAYLOAD_EXECUTABLE:
				bff.Executable(unit)
			case PAYLOAD_HEADERS:
				bff.Headers(unit)
			case PAYLOAD_OBJECTLIST:
				bff.ObjectList(unit)
			case PAYLOAD_SHAREDLIB:
				bff.SharedLib(unit)
			case PAYLOAD_STATICLIB:
				bff.StaticLib(unit)
			default:
				UnexpectedValue(unit.Payload)
				break
			}
		}

		bff.MakeAliases(translatedUnits.Slice())

		return nil
	})

	if err == nil {
		return x.Output.Build(bc)
	} else {
		return BuildStamp{}, err
	}
}

type bffGenerator struct {
	*BffArgsT
	*BffFile
}

func newBffGenerator(dst io.Writer, args *BffArgsT) (result bffGenerator) {
	result = bffGenerator{
		BffArgsT: args,
		BffFile:  NewBffFile(dst, args.Minify.Get()),
	}
	return result
}

func (gen bffGenerator) Executable(unit *Unit) {
	gen.BaseDeliverable(unit, true)
}
func (gen bffGenerator) Headers(unit *Unit) {
	gen.Func("Alias", func() {
		fileset := FileSet{}
		fileset.Append(unit.Source.ExtraFiles...)
		fileset.Append(unit.Libraries...)
		gen.Assign("Targets", fileset)
	}, unit.Target.String())
}
func (gen bffGenerator) ObjectList(unit *Unit) {
	gen.BaseModule(unit, "", true)
}
func (gen bffGenerator) SharedLib(unit *Unit) {
	gen.BaseDeliverable(unit, false)
}
func (gen bffGenerator) StaticLib(unit *Unit) {
	gen.BaseModule(unit, "", false)
}
func (gen bffGenerator) BaseDeliverable(unit *Unit, executable bool) {
	libraries := []string{gen.BaseModule(unit, "-Obj", true)}
	libraries = append(libraries, Stringize(unit.CompileDependencies.Slice()...)...)
	libraries = append(libraries, Stringize(unit.LinkDependencies.Slice()...)...)
	libraries = append(libraries, gen.CustomUnits(unit)...)

	compilerDetails := gen.Compiler(unit.Compiler)

	funcName := "DLL"
	if executable {
		funcName = "Executable"
	}

	gen.Func(funcName, func() {
		gen.Using(compilerDetails)
		gen.Assign("Libraries", MakeBffArray(libraries...))
		gen.Assign("LinkerOptions", unit.LinkerOptions.Join(" "))
		gen.Assign("LinkerOutput", unit.OutputFile)
		gen.Assign("PreBuildDependencies", Stringize(unit.RuntimeDependencies.Slice()...))
	}, unit.Target.String())
}
func (gen bffGenerator) BaseModule(unit *Unit, suffix string, linkLibraryObjects bool) string {
	compilerDetails := gen.Compiler(unit.Compiler)

	var preprocessorDetails BffVar
	if unit.Preprocessor != nil {
		preprocessorDetails = gen.Compiler(unit.Preprocessor)
	}

	UFS.Mkdir(UFS.Transient)

	moduleSource := MakeBffVar(unit.Target.ModuleAlias().String() + "_Source")
	gen.Once(moduleSource, func() {
		gen.Comment("Target source details for %v", unit.ModuleDir)

		var moduleUnity string
		if unit.Unity.Ord() > 0 {
			moduleUnity = (unit.Target.ModuleAlias().String() + "-Unity")
			gen.Func("Unity", func() {
				gen.Assign("Hidden", true)
				gen.Assign("UnityNumFiles", unit.Unity.Ord())
				gen.Assign("UnityInputFiles", unit.Source.SourceFiles)
				gen.Assign("UnityInputPath", unit.Source.SourceDirs)
				gen.Assign("UnityInputPattern", unit.Source.SourceGlobs)
				gen.Assign("UnityInputExcludedFiles", unit.Source.ExcludedFiles)
				gen.Assign("UnityInputExcludePattern", unit.Source.ExcludedGlobs)
				gen.Assign("UnityInputIsolatedFiles", unit.Source.IsolatedFiles)
				gen.Assign("UnityOutputPath", unit.GeneratedDir)
				gen.Assign("UnityOutputPattern", fmt.Sprintf("%s_*_of_%d.cpp", unit.Target.ModuleName, unit.Unity.Ord()))
				if unit.PCH != PCH_DISABLED {
					gen.Assign("UnityPCH", unit.PrecompiledHeader.Basename)
				}
			}, moduleUnity)
		}

		gen.Struct(moduleSource, func() {
			gen.Assign("CompilerInputFilesRoot", unit.ModuleDir)
			if moduleUnity != "" {
				gen.Assign("CompilerInputUnity", moduleUnity)
			} else {
				gen.Assign("CompilerInputFiles", unit.Source.SourceFiles)
				if unit.Source.SourceDirs.Len() > 0 {
					gen.Assign("CompilerInputPattern", unit.Source.SourceGlobs)
					gen.Assign("CompilerInputPath", unit.Source.SourceDirs)
					gen.Assign("CompilerInputPathRecurse", true)
				}
				gen.Assign("CompilerInputExcludedFiles", unit.Source.ExcludedFiles)
				gen.Assign("CompilerInputExcludePattern", unit.Source.ExcludedGlobs)
			}
			if unit.PCH != PCH_DISABLED {
				gen.Assign("PCHInputFile", unit.PrecompiledSource)
			}
		})
	})

	artifactId := (unit.Target.String() + suffix)

	funcName := "Library"
	if linkLibraryObjects {
		funcName = "ObjectList"
	}

	gen.Func(funcName, func() {
		gen.Using(compilerDetails)
		gen.Using(moduleSource)

		if suffix != "" {
			gen.Assign("Hidden", true)
		}

		gen.Assign("CompilerOutputPath", unit.IntermediateDir)
		gen.Assign("CompilerOptions", unit.CompilerOptions.Join(" "))

		if unit.PCH == PCH_MONOLITHIC {
			gen.Assign("PCHOutputFile", unit.PrecompiledObject)
			gen.Assign("PCHOptions", unit.PrecompiledHeaderOptions.Join(" "))
		}

		if unit.Preprocessor != nil {
			gen.Assign("Preprocessor", preprocessorDetails)
			gen.Assign("PreprocessorOptions", unit.PreprocessorOptions.Join(" "))
		}

		if !linkLibraryObjects {
			compileDepAliases := Stringize(unit.CompileDependencies.Slice()...)
			compileDepAliases = append(compileDepAliases, gen.CustomUnits(unit)...)

			gen.Assign("LibrarianAdditionalInputs", compileDepAliases)
			gen.Assign("LibrarianOptions", unit.LibrarianOptions.Join(" "))
			gen.Assign("LibrarianOutput", unit.OutputFile)
		}

		includeDepAliases := Stringize(unit.IncludeDependencies.Slice()...)
		gen.Assign("PreBuildDependencies", includeDepAliases)

	}, artifactId)

	return artifactId
}
func (gen bffGenerator) Compiler(compiler Compiler) BffVar {
	rules := compiler.GetCompiler()
	details := MakeBffVar(rules.CompilerName + "_Details")
	gen.Once(details, func() {
		gen.Func("Compiler", func() {
			gen.Assign("CompilerFamily", rules.CompilerFamily)
			gen.Assign("Root", compiler.WorkingDir())
			gen.Assign("Executable", rules.Executable)
			gen.Assign("ExtraFiles", rules.ExtraFiles)
			gen.Assign("UseLightCache_Experimental", gen.LightCache)
			gen.Assign("UseRelativePaths_Experimental", gen.RelativePaths)
		}, rules.CompilerName)
		gen.Struct(details, func() {
			gen.Assign("Compiler", rules.CompilerName)
			gen.Assign("Librarian", rules.Librarian)
			gen.Assign("Linker", rules.Linker)
		})
	})
	return details
}
func (gen bffGenerator) CustomUnits(unit *Unit) []string {
	return Map(func(custom *CustomUnit) string {
		return gen.BaseModule(&custom.Unit, "", true)
	}, unit.CustomUnits...)
}
func (gen bffGenerator) MakeAliases(units []*Unit) {
	environments := make(map[BuildAlias]*[]TargetAlias, len(units))
	namespaces := make(map[BuildAlias]*[]TargetAlias, len(units))

	for _, u := range units {
		target := u.Target

		if list, ok := environments[u.Target.CompileEnvAlias()]; !ok {
			environments[u.Target.CompileEnvAlias()] = &[]TargetAlias{target}
		} else {
			*list = append(*list, target)
		}

		if list, ok := namespaces[u.Target.NamespaceAlias()]; !ok {
			namespaces[u.Target.NamespaceAlias()] = &[]TargetAlias{target}
		} else {
			*list = append(*list, target)
		}
	}

	for alias, list := range environments {
		gen.Func("Alias", func() {
			gen.Assign("Targets", Stringize(*list...))
		}, alias.String())
	}
	for alias, list := range namespaces {
		gen.Func("Alias", func() {
			gen.Assign("Targets", Stringize(*list...))
		}, alias.String())
	}
}
