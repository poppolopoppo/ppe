
//------------------------------------------------------------------------------
// Library Generation Helper (.lib)
//------------------------------------------------------------------------------
; Inputs :
;   <ProjectName>           name of the project
;   <ProjectPath>           path containing the source files
;   [ProjectLinkType]       project specific linker type (Dll / Lib)
;   [ProjectPCHName]        precompiled header name (default value in Defaults.bff)
;   [ProjectDefines]        project specific defines (default value in Defaults.bff)
;   [ProjectCompilerOptions]project specific compiler options
;   [ProjectLinkerOptions]  project specific linkere options
;   [ProjectPublicDependencies]   project specific public dependencies like dll (default value in Defaults.bff)
;   [ProjectPrivateDependencies]   project specific private dependencies like lib (default value in Defaults.bff)
;   [ProjectExcludedFiles]  project specific excluded files (default value in Defaults.bff)
;   [ProjectForcedIncludes] project specific force includes (default value in Defaults.bff)
;   [ProjectIncludes]       project specific includes (default value in Defaults.bff)
;   [ProjectInputPattern]   project specific input patterns (default value in Defaults.bff)
;   [ProjectLibraries]      project specific libraries (default value in Defaults.bff)
;   [ProjectIsolatedFiles]  project files not included in unity builds but still compiled (default value in Defaults.bff)
;   [ProjectPCHConfig]      project Pre-Compiled Headers configuration to enable/disable PCH (default value in Defaults.bff)
;   [ProjectUseUnity]       project specific boolean : if true use unity input, else only ProjectIsolatedFiles
;   [ProjectUseIncrementalLinker] project specific boolean : if true use incremental linker
;   [ProjectUseLinkTimeCodeGeneration] project specific boolean : if true use LTCG
//------------------------------------------------------------------------------

.EvalParameters = {
    "ProjectPCHName",
    "ProjectDefines",
    "ProjectCompilerOptions",
    "ProjectLinkerOptions",
    "ProjectPublicDependencies",
    "ProjectPrivateDependencies",
    "ProjectExcludedFiles",
    "ProjectIncludes",
    "ProjectIsolatedFiles",
    "ProjectLibraries",
    "ProjectPCHConfig",
    "ProjectUseUnity",
    "ProjectUseIncrementalLinker",
    "ProjectUseLinkTimeCodeGeneration",
}

.DynamicLinkType ? 'Dll'
.ProjectConfigs = {}
.UnityEnabled = .True

ForEach( .CompileConfig in .AllCompileConfigs )
{
    .ProjectConfig = // Visual project config
    [
        Using( .CompileConfig )

        .ProjectLinkType       ? .ConfigLinkType

        // Evaluate parameters for this configuration
        #include "EvalParameters.bff"

        // Project directories
        .IntermediateRoot      = .IntermediatePath + '/$Platform$/$Config$'
        .IntermediatePath      = '$IntermediateRoot$/$ProjectName$'
        .OutputPath            = .BinaryPath
        .UnityDirectory        = '$IntermediatePath$/Unity'

        // Project compiled config
        .ProjectCompileConfig =
        [
            Using( .CompileConfig )

            // Project specific options

            .ProjectCompilerOptions ? ''
            .CompilerOptions + .ProjectCompilerOptions

            .ProjectLinkerOptions ? ''
            .LinkerOptions + .ProjectLinkerOptions

            // Project defines

            .Defines    + "BUILDCONFIG_$Platform$_$Config$"
            .Defines    + 'BUILDCONFIG="$Platform$-$Config$"'
            .Defines    + .ProjectDefines

            // Runtime is selected by config, but these defines are controlled by project
            //  => allows to get statically linked libraries which skips both dll imports & exports

            .Defines_Link_Obj   = { 'STATIC_LINK' }
            .Defines_Link_Lib   = { 'STATIC_LINK' }
            .Defines_Link_Dll   = { 'DYNAMIC_LINK' }
            .Defines            + ."Defines_Link_$ProjectLinkType$"

            // For VCXProject
            .PreprocessorDefinitions    = ''
            .IncludeSearchPath          = ''

            ForEach( .define in .Defines )
            {
                ^CompilerOptions            + ' $CompilerDefineFlag$"$define$"'
                ^PreprocessorOptions        + ' $CompilerDefineFlag$"$define$"'
                ^PreprocessorDefinitions    + ';$define$'
            }

            .ProjectIncludes            + .IncludePaths
                                        + .SourcePath

            // Only for VCXProject
            ForEach( .path in .ProjectIncludes )
            {
                ^IncludeSearchPath          + ';$path$'
            }
            ForEach( .path in .SystemIncludePaths )
            {
                ^IncludeSearchPath          + ';$path$'
            }

            // For actual compilation
            ForEach( .path in .ProjectForcedIncludes )
            {
                ^CompilerOptions            + ' $CompilerForceIncludeFlag$"$path$"'
                ^PreprocessorOptions        + ' $CompilerForceIncludeFlag$"$path$"'
            }
            ForEach( .path in .ProjectIncludes )
            {
                ^CompilerOptions            + ' $CompilerIncludeFlag$"$path$"'
                ^PreprocessorOptions        + ' $CompilerIncludeFlag$"$path$"'
            }
            ForEach( .path in .SystemIncludePaths )
            {
                ^CompilerOptions            + ' $CompilerSystemIncludeFlag$"$path$"'
                ^PreprocessorOptions        + ' $CompilerSystemIncludeFlag$"$path$"'
            }

#if USE_VISUALSTUDIO
            // PDB output path
            .CompilerOptions                + ' /Fd"$IntermediateRoot$/$ProjectName$.$PlatformToolset$.pdb"'
#endif
        ]

        // Append os runtime
        .ProjectCompileConfig   + .CompilerRuntime

        // Complete compile config with PCH
        .ProjectCompileConfigWithPCH = .ProjectCompileConfig
        .ProjectCompileConfigWithoutPCH = .ProjectCompileConfig
        {
            Using( .ProjectCompileConfig )

            Eval( .ProjectPCHConfig )
            ^ProjectCompileConfigWithPCH = .ProjectCompileConfig + .ProjectPCHConfig

            Eval( .PCHDisabled )
            ^ProjectCompileConfigWithoutPCH = .ProjectCompileConfig + .PCHDisabled
        }

        .PurgeTargets = {}

        //If( .ProjectUseUnity == .UnityEnabled )
        // Project Unity
        Unity( '$ProjectName$-Unity-$Platform$-$Config$' )
        {
            Using( .ProjectCompileConfigWithPCH )

            .UnityInputPath             = '$ProjectPath$'
            .UnityOutputPath            = .UnityDirectory
            .UnityInputPattern          = .ProjectInputPattern
            .UnityOutputPattern         = 'Unity_*_of_$UnityNumFiles$.cpp'
            .UnityInputExcludedFiles    = {}

            ForEach( .Filename in .ProjectExcludedFiles )
            {
                ^UnityInputExcludedFiles + "$ProjectPath$/$Filename$"
            }
            ForEach( .Filename in .ProjectIsolatedFiles )
            {
                ^UnityInputExcludedFiles + "$ProjectPath$/$Filename$"
            }
        }

        RemoveDir( '$ProjectName$-Unity-$Platform$-$Config$-Purge' )
        {
            .RemovePaths          = .UnityDirectory
            .RemovePathsPattern   = 'Unity*.cpp'
        }

        .PurgeTargets + '$ProjectName$-Unity-$Platform$-$Config$-Purge'
        //}

        // Object list
        ObjectList( '$ProjectName$-Obj-$Platform$-$Config$' )
        {
            Using( .ProjectCompileConfigWithPCH )

            .CompilerInputFilesRoot = .ProjectPath
            .CompilerOutputPath = .IntermediatePath

            // Isolated files
            .CompilerInputFiles = {}
            ForEach( .Isolated in .ProjectIsolatedFiles )
            {
                ^CompilerInputFiles + "$ProjectPath$/$Isolated$"
            }

            // Unity files IFN
            //If( .ProjectUseUnity == .UnityEnabled )
            //{
                .CompilerInputUnity = '$ProjectName$-Unity-$Platform$-$Config$'
            //}
            // If( .ProjectUseUnity != .UnityEnabled )
            // {
            //     .CompilerInputPath = .ProjectPath
            //     .CompilerInputPattern = .ProjectInputPattern

            //     .CompilerInputFiles = {}
            //     ForEach( .Filename in .ProjectIsolatedFiles )
            //     {
            //         ^CompilerInputFiles + "$ProjectPath$/$Filename$"
            //     }

            //     .CompilerInputExcludedFiles = {}
            //     ForEach( .Filename in .ProjectExcludedFiles )
            //     {
            //         ^CompilerInputExcludedFiles + "$ProjectPath$/$Filename$"
            //     }
            // }

            // Deoptimize files containings 'FASTBUILD_DEOPTIMIZE_OBJECT'
            .DeoptimizeWritableFilesWithToken = true
        }

        RemoveDir( '$ProjectName$-Obj-$Platform$-$Config$-Purge' )
        {
            .RemovePaths        = .IntermediatePath
        }

        .PurgeTargets + '$ProjectName$-Obj-$Platform$-$Config$-Purge'

        // Static library
        Library( '$ProjectName$-Lib-$Platform$-$Config$' )
        {
            Using( .ProjectCompileConfigWithoutPCH )

            .CompilerOutputPath = .IntermediatePath

            .LibrarianOutput    = '$IntermediateRoot$/$ProjectName$.$CompilerLibraryExtension$'
            .LibrarianAdditionalInputs = { '$ProjectName$-Obj-$Platform$-$Config$' }
        }

        RemoveDir( '$ProjectName$-Lib-$Platform$-$Config$-Purge' )
        {
            .RemovePaths        = .IntermediateRoot
            .RemovePathsPattern = "$ProjectName$.*"
        }

        .PurgeTargets + '$ProjectName$-Lib-$Platform$-$Config$-Purge'

        If( .ProjectLinkType == .DynamicLinkType )
        {
            // Dynamic library
            DLL( '$ProjectName$-$DynamicLinkType$-$Platform$-$Config$' )
            {
                Using( .ProjectCompileConfigWithoutPCH )

                .LinkerVerboseOutput = true

                .LinkerOutput       = '$IntermediateRoot$/$ProjectName$-$Platform$-$Config$.$CompilerDllExtension$'
                .LinkerOptions      = "$DllOptions$ $LinkerOptions$"

                If( .ProjectUseIncrementalLinker == .False )
                {
                    ^LinkerOptions  - .LinkerNotIncremental
                                    - .LinkerIncremental
                                    + .LinkerNotIncremental
                }

                If( .ProjectUseLinkTimeCodeGeneration == .False )
                {
                    ^LinkerOptions  - .LinkerWithoutLTCG
                                    - .LinkerWithLTCGIncremental
                                    - .LinkerWithLTCG
                                    + .LinkerWithoutLTCG
                }

                .Libraries          = { '$ProjectName$-Lib-$Platform$-$Config$' }
    #if USE_LIBRARY_DEPENDENCY_INPUT
                .LinkerLinkObjects  = true
                .Libraries          = { '$ProjectName$-Obj-$Platform$-$Config$' }
    #endif
                .Libraries          + .ProjectLibraries

                .ProjectDependencies    = .ProjectPublicDependencies
                                        + .ProjectPrivateDependencies

                ForEach( .ProjectDependency in .ProjectDependencies )
                {
                    ^Libraries + { '$ProjectDependency$-$Platform$-$Config$' }
                }
            }

            RemoveDir( '$ProjectName$-$DynamicLinkType$-$Platform$-$Config$-Purge' )
            {
                .RemovePaths          = .BinaryPath
                .RemovePathsPattern   = "$ProjectName$.$Config$.$Platform$.*"
                .PreBuildDependencies = { '$ProjectName$-Lib-$Platform$-$Config$-Purge' }
    #if USE_LIBRARY_DEPENDENCY_INPUT
                .PreBuildDependencies = { '$ProjectName$-Obj-$Platform$-$Config$-Purge' }
    #endif
            }

            .PurgeTargets + '$ProjectName$-$DynamicLinkType$-$Platform$-$Config$-Purge'
        }

        // Purge alias
        Alias( '$ProjectName$-Purge-$Platform$-$Config$' )
        {
            .Targets = .PurgeTargets
        }

        // Override project directories for visual studio ONLY
#if __WINDOWS__
        Using( .ProjectCompileConfigWithPCH )

        .AnalyzeOptions         ? ''
        .AdditionalOptions      + .AnalyzeOptions
        .BuildLogFile           = "$IntermediateRoot$/$ProjectName$.$Config$.$Platform$.log"
        .Output                 = "$BinaryPath$/$BinaryPrefix$-$Platform$-$Config$.$CompilerBinaryExtension$"
        .OutputDirectory        = "$BinaryPath$"
        .IntermediateDirectory  = "$IntermediatePath$"
        .ProjectBasePath        = "$ProjectPath$"
        .ProjectBuildCommand    = '$VisualStudioFBuildCommand$ $VSBuildOptions$ "$ProjectName$-$Platform$-$Config$"'
        .ProjectRebuildCommand  = '$VisualStudioFBuildCommand$ $VSRebuildOptions$ -clean "$ProjectName$-$Platform$-$Config$"'
        .ProjectCleanCommand    = '$VisualStudioFBuildCommand$ $VSCleanOptions$ -clean "$ProjectName$-Purge-$Platform$-$Config$"'
        .Platform               = .SolutionPlatform

        .ForcedIncludes         = '"$SourcePath$/winnt_version.h"' ; see MSVCBase.bff
        ForEach( .path in .ProjectForcedIncludes )
        {
            ^ForcedIncludes     + ';"$path$"'
        }
#endif
    ]

    ^ProjectConfigs + .ProjectConfig
}

VCXProject( '$ProjectName$-VCXProject' )
{
    Using( .VisualStudioBaseConfig )

    .ProjectBasePath    = .ProjectPath
    .ProjectInputPaths  = .ProjectPath
    .ProjectOutput      = '$SolutionPath$/Output/Projects/$ProjectName$.vcxproj'
    .ProjectAllowedFileExtensions ? { '*.h' }
    .ProjectAllowedFileExtensions + .ProjectInputPattern

    .ProjectFiles       ? {}
    .ProjectFilesAbsolute = {}
    ForEach( .path in .ProjectFiles )
    {
        ^ProjectFilesAbsolute + "$ProjectPath$/$path$"
    }
    .ProjectFiles = .ProjectFilesAbsolute

    // ForEach( .path in .ProjectForcedIncludes )
    // {
    //     ^ProjectFiles   + .path
    // }

    ForEach( .path in .ProjectIsolatedFiles )
    {
        ^ProjectFiles   + "$ProjectPath$/$path$"
    }
}
