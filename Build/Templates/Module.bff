//------------------------------------------------------------------------------
// Module Generation (wrapping Library with additional assumptions)
//------------------------------------------------------------------------------
; Inputs :
;   <ModulePath>                path of the module
;   <ModuleName>                name of the module
;   [ModuleType]                'Library', 'External' or 'Executable' (default is 'Library')
;   [ModuleDefines]             module specific defines
;   [ModulePublicDependencies]  module specific public dependencies
;   [ModulePrivateDependencies] module specific private dependencies
;   [ModuleRuntimeDependencies] module specific runtime dependencies
;   [ModuleForcedIncludes]      module specific relative force includes
;   [ModuleExcludedFiles]       module specific relative excluded files
;   [ModuleFiles]               module specific relative included files
;   [ModuleExtraFiles]          list of files not build but listed in project file
;   [ModuleIsolatedFiles]       module relative files not included in unity builds but still compiled
;   [ModuleIncludePaths]        module specific relative include paths
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// This is simply modeling some asumptions made on modules :
//  - The project name is the project path in .SourceDir
//  - All modules have a Public and a Private subfolder
//  - Private is only accessible in the current module
//  - All module dependencies give access to the Public folder *ONLY*
//  - Public module dependencies are viral : consuming modules needs to also consume those
//  - Private module dependencies are not needed by consuming modules (*SHOULD BE 90% OF THE TIME*)
//------------------------------------------------------------------------------

.ModuleType ? 'Library'
.ModuleDefines ? {}
.ModulePublicDependencies ? {}
.ModulePrivateDependencies ? {}
.ModuleRuntimeDependencies ? {}
.ModuleForcedIncludes ? {}
.ModuleExcludedFiles ? {}
.ModuleFiles ? {}
.ModuleExtraFiles ? {}
.ModuleIsolatedFiles ? {}
.ModuleIncludePaths ? {}

.ModuleIsolatedFiles_Executable = .ModuleIsolatedFiles
.ModuleIsolatedFiles_External = .ModuleIsolatedFiles
.ModuleIsolatedFiles_Library = .ModuleIsolatedFiles + 'ModuleExport.cpp'
.ModuleIsolatedFiles = .'ModuleIsolatedFiles_$ModuleType$'

.ProjectName = '$ModulePath$/$ModuleName$'
.ProjectPath = '$SourcePath$/$ProjectName$'

////////////////////////////////////////////////////////////////////////
// Register the module details in global vars, propagate dependeencies
////////////////////////////////////////////////////////////////////////

^ModuleList + .ProjectName
.ModuleKey = .ProjectName - '/' - '-'

.ProjectPrivateDependencies = .ModulePrivateDependencies
.ProjectPublicDependencies = .ModulePublicDependencies
.ProjectRuntimeDependencies = .ModuleRuntimeDependencies

.ModulePublicDependencies = {}
.ModuleRuntimeDependencies = {}

.LocalModules =
[
    Using( ^AllModules )

    ForEach( .Module in .ProjectPublicDependencies )
    {
        .DependencyKey = .Module - '/' - '-'
        Using( .'$DependencyKey$' )
        ForEach( .Dependency in .PublicDependencies )
        {
            If( .Dependency not in .ModulePublicDependencies )
            {
                ^ModulePublicDependencies + .Dependency
            }
        }
        ForEach( .Dependency in .RuntimeDependencies )
        {
            If( .Dependency not in .ModuleRuntimeDependencies )
            {
                ^ModuleRuntimeDependencies + .Dependency
            }
        }
        If( .Module not in .ModulePublicDependencies )
        {
            ^ModulePublicDependencies + .Module
        }
    }

    ForEach( .Module in .ProjectRuntimeDependencies )
    {
        .DependencyKey = .Module - '/' - '-'
        Using( .'$DependencyKey$' )
        ForEach( .Dependency in .RuntimeDependencies )
        {
            If( .Dependency not in .ModuleRuntimeDependencies )
            {
                ^ModuleRuntimeDependencies + .Dependency
            }
        }
        If( .Module not in .ModuleRuntimeDependencies )
        {
            ^ModuleRuntimeDependencies + .Module
        }
    }

    .'$ModuleKey$' =
    [
        .PathName = ^ProjectName
        .Basename = ^ModuleName
        .Path = ^ProjectPath
        .PublicDependencies = ^ModulePublicDependencies
        .RuntimeDependencies = ^ModuleRuntimeDependencies
    ]
]

^AllModules = .LocalModules

////////////////////////////////////////////////////////////////////////
// Configure project settings from higher level module settings
////////////////////////////////////////////////////////////////////////

.BinaryPrefix ? .ModuleName
.ProjectDefines = .ModuleDefines
.ProjectExcludedFiles = .ModuleExcludedFiles
.ProjectFiles = .ModuleFiles + .ModuleExtraFiles
.ProjectIsolatedFiles = .ModuleIsolatedFiles
.ProjectSolutionFolder = .ModulePath

.ProjectIncludes ? {}
.ProjectIncludes +
{
    '$ProjectPath$',
    '$ProjectPath$/Public',
    '$ProjectPath$/Private'
}
ForEach( .Path in .ModuleIncludePaths )
{
    ^ProjectIncludes + '$ProjectPath$/$Path$'
}

.ProjectPrivateDependencies = .ModulePrivateDependencies
.ProjectPublicDependencies = .ModulePublicDependencies
.ProjectRuntimeDependencies = .ModuleRuntimeDependencies

.ModuleAllDependencies  = .ModulePrivateDependencies
                        + .ModulePublicDependencies
ForEach( .Module in .ModuleAllDependencies )
{
    ^ProjectIncludes + '$SourcePath$/$Module$/Public'
}

.ProjectForcedIncludes = {}
ForEach( .Module in .ModulePublicDependencies )
{
    ^ProjectForcedIncludes + '$SourcePath$/$Module$/ModuleExport.h'
}
ForEach( .File in .ModuleForcedIncludes )
{
    .IncludePath = '$ProjectPath$/$File$'
    ^ProjectForcedIncludes + .IncludePath
}

////////////////////////////////////////////////////////////////////////
// Finally recurse to either Library.bff or Executable.bff
////////////////////////////////////////////////////////////////////////

#include "$ModuleType$.bff"

Print( "[+] $ModuleType$ module <$ProjectName$>" )
