package generic

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"io"
	"strings"
)

var Glslang = RegisterArchetype("SDK/GLSLANG", func(rules *ModuleRules) {
	extractDir := rules.ModuleDir.AbsoluteFolder(rules.Exports.Get("Glslang/Path"))

	LogTrace("glslang: use '%v' as extraction path", extractDir)

	rules.Generate(PUBLIC, "glslang-headers.generated.h", GlslangGeneratedHeader{
		ExtractDir: extractDir,
	})
})

/***************************************
 * Glslang header generator
 ***************************************/

type GlslangGeneratedHeader struct {
	ExtractDir Directory
}

func (g GlslangGeneratedHeader) GetDigestable(o *bytes.Buffer) {
	o.WriteString("GlslangGeneratedHeader-1.0.0")
	g.ExtractDir.GetDigestable(o)
}
func (g GlslangGeneratedHeader) Generate(ctx GeneratorContext, dst io.Writer) error {
	var useDebugSDK bool
	switch ctx.Env.GetConfig().ConfigType {
	case CONFIG_DEBUG, CONFIG_FASTDEBUG:
		useDebugSDK = true
	case CONFIG_DEVEL, CONFIG_TEST, CONFIG_SHIPPING:
		useDebugSDK = false
	default:
		UnexpectedValue(ctx.Env.GetConfig().ConfigType)
	}

	config := getGlslangConfig(useDebugSDK)
	downloader := getGlslangDownloader(config)
	ctx.DependsOn(downloader)

	extractDir := g.ExtractDir.Folder(config)
	ar := getGlslangExtractor(downloader, extractDir)
	ctx.DependsOn(ar)

	librariesRe := MakeGlobRegexp(glslangGlobLibraries...)
	for _, x := range ar.ExtractedFiles {
		rel := x.Relative(ar.Destination)
		if librariesRe.MatchString(rel) {
			ctx.Unit.Facet.Libraries.Append(x)
			ctx.Unit.TransitiveFacet.Libraries.Append(x)
		}
	}

	cpp := NewCppFile(dst, false)
	cpp.Comment("Glslang header generated by %v/%v", MAIN_SIGNATURE, ctx.Unit.Target)
	cpp.Pragma("once")

	includeDir := ar.Destination.Folder("Include")
	includeRe := MakeGlobRegexp(glslangGlobIncludes...)
	for _, x := range ar.ExtractedFiles {
		rel := x.Relative(ar.Destination)
		if includeRe.MatchString(rel) {
			cpp.Pragma("include_alias(\"%v\", \"%v\")",
				strings.ReplaceAll(x.Relative(includeDir), "\\", "/"),
				strings.ReplaceAll(x.Relative(UFS.Source), "\\", "/"))
		}
	}

	return nil
}

/***************************************
 * Download Glslang SDK release from Github
 ***************************************/

var glslangGlobIncludes = NewStringSet(
	"include/glslang/Include/*",
	"include/glslang/Public/*",
	"include/glslang/MachineIndependent/*",
	"include/glslang/SPIRV/*",
)
var glslangGlobLibraries = NewStringSet(
	"lib/GenericCodeGen*",
	"lib/glslang*",
	"lib/MachineIndependent*",
	"lib/OGLCompiler*",
	"lib/OSDependent*",
	"lib/SPIRV*",
)

func getGlslangExtractor(download *Downloader, extractDir Directory) *ArchiveExtractor {
	return NewArchiveExtractorFromExt(
		download.Destination,
		extractDir,
		glslangGlobIncludes.Concat(glslangGlobLibraries),
		download.Alias())
}

var getGlslangConfig = MemoizePod(func(debug bool) string {
	var config string
	switch CurrentHost().Id {
	case HOST_WINDOWS:
		config = "windows-x64"
	case HOST_LINUX:
		config = "linux"
	case HOST_DARWIN:
		config = "osx"
	default:
		NotImplemented("glslang: no support available for platform '%s'", CurrentHost().Id)
	}
	if debug {
		config += "-Debug"
	} else {
		config += "-Release"
	}
	return config
})

var getGlslangDownloader = MemoizePod(func(config string) *Downloader {
	return NewDownloader(
		"http://github.com/KhronosGroup/glslang/releases/download/master-tot/glslang-master-"+config+".zip",
		UFS.Transient.Folder("SDK").File("glslang-master-"+config+".zip"),
		DOWNLOAD_DEFAULT)
})
