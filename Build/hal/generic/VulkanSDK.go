package generic

import (
	. "build/compile"
	. "build/utils"
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"regexp"
	"strings"
)

var Vulkan = RegisterArchetype("SDK/VULKAN", func(rules *ModuleRules) {
	bindingsFile := rules.ModuleDir.AbsoluteFile(rules.Exports.Get("Vulkan/Bindings"))
	headersDir := rules.ModuleDir.AbsoluteFolder(rules.Exports.Get("Vulkan/Path"))

	LogTrace("vulkan: use bindings declared in file '%v'", bindingsFile)
	LogTrace("vulkan: use '%v' as vulkan include path", headersDir)

	rules.Generate(PUBLIC, "vulkan-exports.generated.h", VulkanGeneratedHeader{
		BindingsFile: bindingsFile,
		IncludeDir:   headersDir,
	})

	rules.Generate(PRIVATE, "vulkan-exports.generated.cpp", VulkanGeneratedSource{
		GeneratedHeader: "vulkan-exports.generated.h",
		BindingsFile:    bindingsFile,
		IncludeDir:      headersDir,
	})
})

/***************************************
 * Vulkan generated header
 ***************************************/

var re_vkIdentifier = regexp.MustCompile(`^\w+`)

type VulkanGeneratedHeader struct {
	BindingsFile Filename
	IncludeDir   Directory
}

func (g VulkanGeneratedHeader) GetDigestable(o *bytes.Buffer) {
	o.WriteString("VulkanGeneratedHeader-1.0.0")
	g.BindingsFile.GetDigestable(o)
	g.IncludeDir.GetDigestable(o)
}
func (g VulkanGeneratedHeader) Generate(ctx GeneratorContext, dst io.Writer) error {
	vk := GetVulkanInterface(g.IncludeDir, g.BindingsFile)
	ctx.DependsOn(vk)

	cpp := NewCppFile(dst, false)
	cpp.Comment("Vulkan header generated by %v/%v", MAIN_SIGNATURE, ctx.Unit.Target)
	cpp.Pragma("once")
	cpp.Include("Container/BitMask.h")
	for _, x := range vk.Headers {
		cpp.Include(strings.ReplaceAll(x.Relative(UFS.Source), "\\", "/"))
	}

	cpp.IfnDef("VKLOG_APICALL", func() {
		cpp.Define("VKLOG_APICALL(_NAME, ...)", "NOOP()")
	})

	makeExtensionEnumDecl := func(name string, exts []VkExtension) {
		cpp.Comment(name)
		cpp.EnumC99(name, "uint32_t", func() {
			cpp.Println(name + "_unknown = 0,")
			for _, x := range exts {
				cpp.IfDef(x.Name, func() {
					if len(x.Requires) > 0 {
						cpp.Println("%s, // requires: %v", getVkExtensionFlag(x.Name), x.Requires.Join(", "))
					} else {
						cpp.Println("%s,", getVkExtensionFlag(x.Name))
					}
				})
			}
			cpp.Println(name + "_count,")
		})

		cpp.Statement("using %s_set = PPE::TFixedSizeBitMask<static_cast<uint32_t>(%s_count)>", name, name)
		cpp.Func(name+"_name", "const char*", []string{name + " ext"}, "", nil)
		cpp.Func(name+"_from", name, []string{"const char* name"}, "", nil)
		cpp.Func(name+"s_available", name+"_set", []string{}, "", nil)
		cpp.Func(name+"s_require", name+"_set", []string{"const " + name + "_set& in"}, "", nil)
		cpp.Func("operator &", "CONSTEXPR bool", []string{"const " + name + "_set& bits", name + " ext"}, "", func() {
			cpp.Statement("return bits.Get(static_cast<size_t>(ext))")
		})
		cpp.Func("operator +=", "CONSTEXPR "+name+"_set&", []string{name + "_set& bits", name + " ext"}, "", func() {
			cpp.Statement("bits.SetTrue(static_cast<size_t>(ext)); return bits")
		})
		cpp.Func("operator -=", "CONSTEXPR "+name+"_set&", []string{name + "_set& bits", name + " ext"}, "", func() {
			cpp.Statement("bits.SetFalse(static_cast<size_t>(ext)); return bits")
		})
	}

	makePfnDecl := func(funcs []VkFunction) {
		n := len(funcs)
		for i, x := range funcs {
			cpp.LazyIfDef(x.Requires, func() {
				if x.VkFunctionPointer != nil {
					cpp.Statement("PFN_%s %s{ nullptr }", x.Name, x.Name)
				}
			}, i+1 == n)
		}
	}

	makePfnWrapper := func(ptr string, funcs []VkFunction) {
		n := len(funcs)
		for i, x := range funcs {
			cpp.LazyIfDef(x.Requires, func() {
				if x.VkFunctionPointer != nil {
					funcRes := `VKAPI_ATTR FORCE_INLINE ` + x.Return
					if x.HasReturn() {
						funcRes = "NODISCARD " + funcRes
					}
					cpp.Func(x.Name, funcRes, Stringize(x.Args...), "const", func() {
						argNames := Map(func(a VkFunctionArg) string { return re_vkIdentifier.FindString(a.Name) }, x.Args...)
						argList := strings.Join(argNames, ", ")
						funCall := fmt.Sprintf("%s->%s(%s)", ptr, x.Name, argList)
						cpp.Statement(fmt.Sprintf("VKLOG_APICALL(%s, %s)", x.Name, argList))
						if x.HasReturn() {
							cpp.Statement("return " + funCall)
						} else {
							cpp.Statement(funCall)
						}
					})
				}
			}, i+1 == n)
		}
	}

	cpp.Namespace("vk", func() {
		// api_version
		cpp.EnumC99("api_version", "uint32_t", func() {
			for _, x := range vk.Versions {
				cpp.Println("API_version_%s = %s,", x[len(x)-3:], x)
			}
			if len(vk.Versions) > 0 {
				cpp.Println("API_version_latest = %v,", vk.Versions[len(vk.Versions)-1])
			}
		})
		// extensions
		makeExtensionEnumDecl("instance_extension", vk.InstanceExts)
		makeExtensionEnumDecl("device_extension", vk.DeviceExts)
		cpp.Statement(`instance_extension_set instance_extensions_require(const device_extension_set& in)`)
		// exported_api
		cpp.Struct("DLL_EXPORT exported_api", func() {
			makePfnDecl(vk.ExportedFuncs)
		})
		// global_api
		cpp.Struct("DLL_EXPORT global_api", func() {
			cpp.Statement("static const global_api g_dummy")
			cpp.Statement("const exported_api* exported_api_{ nullptr }")
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{"const exported_api* api"}, "", nil)
			makePfnDecl(vk.ExportedFuncs)
			makePfnDecl(vk.GlobalFuncs)
		})
		// instance_api
		cpp.Struct("DLL_EXPORT instance_api", func() {
			cpp.Statement("static const instance_api g_dummy")
			cpp.Statement("api_version version_{ API_version_latest }")
			cpp.Statement("const global_api* global_api_{ nullptr }")
			cpp.Statement("instance_extension_set instance_extensions_{}")
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{
				"const global_api* api",
				"VkInstance vkInstance",
				"api_version version",
				"const instance_extension_set& required",
				"instance_extension_set optional = PPE::Default"}, "", nil)
			cpp.Func("setup_backward_compatibility", "void", []string{}, "", nil)
			makePfnDecl(vk.InstanceFuncs)
		})
		// instance_fn
		cpp.Struct("DLL_EXPORT instance_fn", func() {
			cpp.Println_NoIndent("protected:")
			cpp.Statement("friend struct device_api")
			cpp.Statement("const instance_api* instance_api_{ nullptr }")
			cpp.Println_NoIndent("public:")
			cpp.Statement("instance_fn() = default")
			cpp.Println("CONSTEXPR instance_fn(const instance_api* api) : instance_api_(api) {}")
			cpp.Func("api", "const instance_api*", []string{}, "const", func() {
				cpp.Statement("return instance_api_")
			})
			cpp.Func("version", "api_version", []string{}, "const", func() {
				cpp.Statement("return instance_api_->version_")
			})
			cpp.Func("instance_extensions", "const instance_extension_set&", []string{}, "const", func() {
				cpp.Statement("return instance_api_->instance_extensions_")
			})
			makePfnWrapper("instance_api_->global_api_->exported_api_", vk.ExportedFuncs)
			makePfnWrapper("instance_api_->global_api_", vk.GlobalFuncs)
			makePfnWrapper("instance_api_", vk.InstanceFuncs)
		})
		// device_api
		cpp.Struct("DLL_EXPORT device_api", func() {
			cpp.Statement("static const device_api g_dummy")
			cpp.Statement("const instance_api* instance_api_{ nullptr }")
			cpp.Statement("device_extension_set device_extensions_{}")
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{
				"const instance_api* api",
				"VkDevice vkDevice",
				"const device_extension_set& required",
				"device_extension_set optional = PPE::Default"}, "", nil)
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{
				"const instance_fn& fn",
				"VkDevice vkDevice",
				"const device_extension_set& required",
				"device_extension_set optional = PPE::Default"}, "", nil)
			cpp.Func("setup_backward_compatibility", "void", []string{}, "", nil)
			makePfnDecl(vk.DeviceFuncs)
		})
		// device_fn
		cpp.Struct("DLL_EXPORT device_fn", func() {
			cpp.Println_NoIndent("protected:")
			cpp.Statement("const device_api* device_api_{ nullptr }")
			cpp.Println_NoIndent("public:")
			cpp.Statement("device_fn() = default")
			cpp.Println("CONSTEXPR device_fn(const device_api* api) : device_api_(api) {}")
			cpp.Func("api", "const device_api*", []string{}, "const", func() {
				cpp.Statement("return device_api_")
			})
			cpp.Func("version", "api_version", []string{}, "const", func() {
				cpp.Statement("return device_api_->instance_api_->version_")
			})
			cpp.Func("device_extensions", "const device_extension_set&", []string{}, "const", func() {
				cpp.Statement("return device_api_->device_extensions_")
			})
			makePfnWrapper("device_api_->instance_api_", vk.InstanceFuncs)
			makePfnWrapper("device_api_", vk.DeviceFuncs)
		})
	})

	return nil
}

/***************************************
 * Vulkan generated source
 ***************************************/

type VulkanGeneratedSource struct {
	GeneratedHeader string
	BindingsFile    Filename
	IncludeDir      Directory
}

func (g VulkanGeneratedSource) GetDigestable(o *bytes.Buffer) {
	o.WriteString("VulkanGeneratedSource-1.0.0")
}
func (g VulkanGeneratedSource) Generate(ctx GeneratorContext, dst io.Writer) error {
	vk := GetVulkanInterface(g.IncludeDir, g.BindingsFile)
	ctx.DependsOn(vk)

	cpp := NewCppFile(dst, false)
	cpp.Comment("Vulkan source generated by %v/%v", MAIN_SIGNATURE, ctx.Unit.Target)
	cpp.Pragma("once")
	cpp.Include(g.GeneratedHeader)
	cpp.Include("IO/StringView.h")

	makeExtensionEnumDef := func(name string, exts []VkExtension) {
		cpp.Comment(name)
		cpp.Func(name+"_name", "const char*", []string{name + " ext"}, "", func() {
			cpp.Switch("ext", func() {
				for _, x := range exts {
					cpp.IfDef(x.Name, func() {
						cpp.Statement("case %s: return %s", getVkExtensionFlag(x.Name), x.Name)
					})
				}
				cpp.Statement("default: return nullptr")
			})
		})
		cpp.Func(name+"_from", name, []string{"const char* name"}, "", func() {
			cpp.Statement("using namespace PPE")
			cpp.Switch("hash_strI_constexpr(name)", func() {
				for _, x := range exts {
					cpp.IfDef(x.Name, func() {
						cpp.Println(`case hash_strI_constexpr(%s):`, x.Name)
						cpp.ScopeIndent(func() {
							cpp.Statement(`return (EqualsI(MakeCStringView(name), %s) ? %s : %s_unknown)`,
								x.Name, getVkExtensionFlag(x.Name), name)
						})
					})
				}
				cpp.Statement("default: return %s_unknown", name)
			})
		})
		cpp.Func(name+"s_available", name+"_set", []string{}, "", func() {
			cpp.Statement("%s_set avail{}", name)
			for _, x := range exts {
				cpp.IfDef(x.Name, func() {
					cpp.Statement("avail += %s", getVkExtensionFlag(x.Name))
				})
			}
			cpp.Statement("return avail")
		})
		cpp.Func(name+"s_require", name+"_set", []string{"const " + name + "_set& in"}, "", func() {
			cpp.Statement("%s_set required{ in }", name)
			for i := range exts {
				x := exts[len(exts)-1-i] // reverse order: assume extensions are sorted by dependencies
				if len(x.Requires) > 0 {
					cpp.IfDef(x.Name, func() {
						hasExt := fmt.Sprintf("in & %s", getVkExtensionFlag(x.Name))
						cpp.If(hasExt, func() {
							for _, req := range x.Requires {
								cpp.Statement("required += %s", getVkExtensionFlag(req))
							}
						})
					})
				}
			}
			cpp.Statement("return required")
		})
	}

	makePfnDummy := func(funcs []VkFunction) {
		n := len(funcs)
		for i, x := range funcs {
			cpp.LazyIfDef(x.Requires, func() {
				if x.VkFunctionPointer != nil {
					cpp.Print("/* %s */", x.Name)
					switch strings.ToUpper(x.Return) {
					case "VOID":
						cpp.Println("[](auto...) -> void {},")
					case "VKRESULT":
						var value string
						if len(x.Requires) > 0 {
							value = "VK_ERROR_EXTENSION_NOT_PRESENT"
						} else {
							value = "VK_NOT_READY"
						}
						cpp.Println("[](auto...) -> VkResult { return %s; },", value)
					case "VKBOOL32":
						cpp.Println("[](auto...) -> VkBool32 { return VK_FALSE; },")
					case "UINT64_T", "UINT32_T", "VKDEVICESIZE", "VKDEVICEADDRESS", "VKFLAGS":
						cpp.Println("[](auto...) -> %s { return 0; },", x.Return)
					default:
						cpp.Println("[](auto...) -> %s { return VK_NULL_HANDLE; },", x.Return)
					}
				}
			}, i+1 == n)
		}
	}

	cpp.Namespace("vk", func() {
		// helpers
		cpp.Println("template <typename _PFN>")
		cpp.Func("attach_pfn_", "NODISCARD FORCE_INLINE static bool", []string{
			"_PFN* outPFN",
			"const global_api& api",
			"const char* name"}, "", func() {
			cpp.Statement(`*outPFN = reinterpret_cast<_PFN>(api.exported_api_->vkGetInstanceProcAddr(VK_NULL_HANDLE, name))`)
			cpp.Statement(`return (!!*outPFN)`)
		})
		cpp.Println("template <typename _PFN>")
		cpp.Func("attach_pfn_", "NODISCARD FORCE_INLINE static bool", []string{
			"_PFN* outPFN",
			"const instance_api& api",
			"VkInstance vkInstance",
			"const char* name"}, "", func() {
			cpp.Statement(`*outPFN = reinterpret_cast<_PFN>(api.global_api_->exported_api_->vkGetInstanceProcAddr(vkInstance, name))`)
			cpp.Statement(`return (!!*outPFN)`)
		})
		cpp.Println("template <typename _PFN>")
		cpp.Func("attach_pfn_", "NODISCARD FORCE_INLINE static bool", []string{
			"_PFN* outPFN",
			"const device_api& api",
			"VkDevice vkDevice",
			"const char* name"}, "", func() {
			cpp.Statement(`*outPFN = reinterpret_cast<_PFN>(api.instance_api_->vkGetDeviceProcAddr(vkDevice, name))`)
			cpp.Statement(`return (!!*outPFN)`)
		})
		// extensions
		makeExtensionEnumDef("instance_extension", vk.InstanceExts)
		makeExtensionEnumDef("device_extension", vk.DeviceExts)
		// instance extensions require by each device extension
		cpp.Func("instance_extensions_require", "instance_extension_set", []string{"const device_extension_set& in"}, "", func() {
			cpp.Statement("instance_extension_set required{ PPE::Meta::ForceInit }")
			for i := range vk.DeviceExts {
				x := vk.DeviceExts[len(vk.DeviceExts)-1-i] // reverse order: assume extensions are sorted by dependencies
				if len(x.Foreign) > 0 {
					cpp.IfDef(x.Name, func() {
						hasExt := fmt.Sprintf("in & %s", getVkExtensionFlag(x.Name))
						cpp.If(hasExt, func() {
							for _, req := range x.Foreign {
								cpp.Statement("required += %s", getVkExtensionFlag(req))
							}
						})
					})
				}
			}
			cpp.Statement("return required")
		})
		// global_api
		cpp.Declare("global_api::g_dummy", "const global_api", func() {
			cpp.Println("nullptr/* exported_api_ */,")
			makePfnDummy(vk.ExportedFuncs)
			makePfnDummy(vk.GlobalFuncs)
		})
		cpp.Func("global_api::attach_return_error", "const char*", []string{"const exported_api* api"}, "", func() {
			cpp.Statement("exported_api_ = api")
			for i, x := range vk.ExportedFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						available := fmt.Sprintf("nullptr == (%v = api->%v)", x.Name, x.Name)
						cpp.If(available, func() {
							cpp.Statement(`return "%v"`, x.Name)
						})
					}
				}, i+1 == len(vk.GlobalFuncs))
			}
			for i, x := range vk.GlobalFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						available := fmt.Sprintf(`!attach_pfn_(&%s, *this, "%s")`, x.Name, x.Name)
						cpp.If(available, func() {
							cpp.Statement(`return "%v"`, x.Name)
						})
					}
				}, i+1 == len(vk.ExportedFuncs))
			}
			cpp.Statement("return nullptr/* no error */")
		})
		// instance_api
		cpp.Declare("instance_api::g_dummy", "const instance_api", func() {
			cpp.Println("API_version_latest,")
			cpp.Println("nullptr/* global_api_ */,")
			cpp.Println("{ PPE::Meta::ForceInit }/* instance_extensions_ */,")
			makePfnDummy(vk.InstanceFuncs)
		})
		cpp.Func("instance_api::attach_return_error", "const char*", []string{
			"const global_api* api",
			"VkInstance vkInstance",
			"api_version version",
			"const instance_extension_set& required",
			"instance_extension_set optional"}, "", func() {
			cpp.Statement("version_ = version")
			cpp.Statement("global_api_ = api")
			cpp.Statement("const instance_extension_set user = required | optional")
			cpp.Statement("instance_extensions_ = user")
			for i, x := range vk.InstanceFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						if x.Requires == "" {
							available := fmt.Sprintf(
								`(version_ >= %s) && `+
									`!attach_pfn_(&%s, *this, vkInstance, "%s")`,
								getVkExtensionFlag(x.Version), x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement(`return "%v"`, x.Name)
							})
						} else {
							flag := getVkExtensionFlag(x.Requires)
							available := fmt.Sprintf(
								`(user & %s) && `+
									`!attach_pfn_(&%s, *this, vkInstance, "%s")`,
								flag, x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement("instance_extensions_ -= %v", flag)
								cpp.Statement(`if (required & %v) return "%v"`, flag, x.Name)
								cpp.Statement(`%v = g_dummy.%v`, x.Name, x.Name)
							})
						}
					}
				}, i+1 == len(vk.InstanceFuncs))
			}
			cpp.Statement("return nullptr/* no error */")
		})
		cpp.Func("instance_api::setup_backward_compatibility", "void", []string{}, "", func() {
			cpp.Statement("const uint32_t vkVersion = static_cast<uint32_t>(version_)")
			cpp.Statement("PPE::Unused(vkVersion)")
			for i, x := range vk.InstanceBwds {
				from := vk.InstanceFuncs[x.From]
				to := vk.InstanceFuncs[x.To]
				available := fmt.Sprintf("defined(%s) && defined(%v)", x.Version, from.Requires)
				cpp.LazyIfMacro(available, func() {
					available := fmt.Sprintf("vkVersion >= %v", x.Version)
					cpp.If(available, func() {
						cpp.Statement("Assert(%s)", to.Name)
						cpp.Statement("%s = %s", from.Name, to.Name)
					})
				}, i+1 == len(vk.InstanceBwds))
			}
		})
		// device_api
		cpp.Declare("device_api::g_dummy", "const device_api", func() {
			cpp.Println("nullptr/* instance_api_ */,")
			cpp.Println("{ PPE::Meta::ForceInit }/* device_extensions_ */,")
			makePfnDummy(vk.DeviceFuncs)
		})
		cpp.Func("device_api::attach_return_error", "const char*", []string{
			"const instance_api* api",
			"VkDevice vkDevice",
			"const device_extension_set& required",
			"device_extension_set optional"}, "", func() {
			cpp.Statement("instance_api_ = api")
			cpp.Statement("const device_extension_set user = required | optional")
			cpp.Statement("device_extensions_ = user")
			for i, x := range vk.DeviceFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						if x.Requires == "" {
							available := fmt.Sprintf(
								`(instance_api_->version_ >= %s) && `+
									`!attach_pfn_(&%s, *this, vkDevice, "%s")`,
								getVkExtensionFlag(x.Version), x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement(`return "%v"`, x.Name)
							})
						} else {
							flag := getVkExtensionFlag(x.Requires)
							available := fmt.Sprintf(
								`(user & %s) && `+
									`!attach_pfn_(&%s, *this, vkDevice, "%s")`,
								flag, x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement("device_extensions_ -= %v", flag)
								cpp.Statement(`if (required & %v) return "%v"`, flag, x.Name)
								cpp.Statement(`%v = g_dummy.%v`, x.Name, x.Name)
							})
						}
					}
				}, i+1 == len(vk.DeviceFuncs))
			}
			cpp.Statement("return nullptr/* no error */")
		})
		cpp.Func("device_api::attach_return_error", "const char*", []string{
			"const instance_fn& fn",
			"VkDevice vkDevice",
			"const device_extension_set& required",
			"device_extension_set optional"}, "", func() {
			cpp.Statement("return attach_return_error(fn.instance_api_, vkDevice, required, optional)")
		})
		cpp.Func("device_api::setup_backward_compatibility", "void", []string{}, "", func() {
			cpp.Statement("const uint32_t vkVersion = static_cast<uint32_t>(instance_api_->version_)")
			cpp.Statement("PPE::Unused(vkVersion)")
			for i, x := range vk.DeviceBwds {
				from := vk.DeviceFuncs[x.From]
				to := vk.DeviceFuncs[x.To]
				available := fmt.Sprintf("defined(%s) && defined(%v)", x.Version, from.Requires)
				cpp.LazyIfMacro(available, func() {
					available := fmt.Sprintf("vkVersion >= %v", x.Version)
					cpp.If(available, func() {
						cpp.Statement("Assert(%s)", to.Name)
						cpp.Statement("%s = %s", from.Name, to.Name)
					})
				}, i+1 == len(vk.DeviceBwds))
			}
		})
	})

	return nil
}

/***************************************
 * Vulkan API parsing
 ***************************************/

func getVkExtensionFlag(macro string) (flag string) {
	flag = strings.TrimSuffix(macro, "_EXTENSION_NAME")
	flag = strings.TrimPrefix(flag, "VK_")
	sep := strings.Index(flag, "_")
	return flag[:sep] + "_" + strings.ToLower(flag[sep+1:])
}

func getVkVersionFlag(macro string) (flag string) {
	flag = strings.TrimPrefix(macro, "VK_")
	sep := strings.Index(flag, "_")
	return flag[:sep] + "_" + strings.ToLower(flag[sep+1:])
}

type VkBindingType string

const (
	VK_EXPORTED_FUNCTION                      VkBindingType = "VK_EXPORTED_FUNCTION"
	VK_GLOBAL_LEVEL_FUNCTION                  VkBindingType = "VK_GLOBAL_LEVEL_FUNCTION"
	VK_INSTANCE_LEVEL_FUNCTION                VkBindingType = "VK_INSTANCE_LEVEL_FUNCTION"
	VK_INSTANCE_LEVEL_EXTENSION               VkBindingType = "VK_INSTANCE_LEVEL_EXTENSION"
	VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION VkBindingType = "VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION"
	VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY  VkBindingType = "VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY"
	VK_DEVICE_LEVEL_FUNCTION                  VkBindingType = "VK_DEVICE_LEVEL_FUNCTION"
	VK_DEVICE_LEVEL_EXTENSION                 VkBindingType = "VK_DEVICE_LEVEL_EXTENSION"
	VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION   VkBindingType = "VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION"
	VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY    VkBindingType = "VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY"
)

func vkAllBindingTypes() []VkBindingType {
	return []VkBindingType{
		VK_EXPORTED_FUNCTION,
		VK_GLOBAL_LEVEL_FUNCTION,
		VK_INSTANCE_LEVEL_FUNCTION,
		VK_INSTANCE_LEVEL_EXTENSION,
		VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION,
		VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY,
		VK_DEVICE_LEVEL_FUNCTION,
		VK_DEVICE_LEVEL_EXTENSION,
		VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION,
		VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY,
	}
}
func (v VkBindingType) String() string {
	return string(v)
}
func (v *VkBindingType) Set(in string) error {
	switch strings.ToUpper(in) {
	case VK_EXPORTED_FUNCTION.String():
		*v = VK_EXPORTED_FUNCTION
	case VK_GLOBAL_LEVEL_FUNCTION.String():
		*v = VK_GLOBAL_LEVEL_FUNCTION
	case VK_INSTANCE_LEVEL_FUNCTION.String():
		*v = VK_INSTANCE_LEVEL_FUNCTION
	case VK_INSTANCE_LEVEL_EXTENSION.String():
		*v = VK_INSTANCE_LEVEL_EXTENSION
	case VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION.String():
		*v = VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION
	case VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY.String():
		*v = VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY
	case VK_DEVICE_LEVEL_FUNCTION.String():
		*v = VK_DEVICE_LEVEL_FUNCTION
	case VK_DEVICE_LEVEL_EXTENSION.String():
		*v = VK_DEVICE_LEVEL_EXTENSION
	case VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION.String():
		*v = VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION
	case VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY.String():
		*v = VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY
	default:
		UnexpectedValue(in)
	}
	return nil
}
func (v VkBindingType) GetDigestable(o *bytes.Buffer) {
	o.WriteString(v.String())
}

type VkBinding struct {
	Kind VkBindingType
	Args StringSet
}

func (b VkBinding) String() string {
	return fmt.Sprintf("%s(%s)",
		b.Kind, strings.Join(b.Args, ", "))
}
func (b VkBinding) GetDigestable(o *bytes.Buffer) {
	o.WriteString(b.Kind.String())
	for _, x := range b.Args {
		o.WriteString(x)
	}
}

type VkEnumValue KeyValuePair[string, int32]

func (x VkEnumValue) GetDigestable(o *bytes.Buffer) {
	o.WriteString(x.Key)
	o.WriteByte(byte((x.Value >> 0) & 0xFF))
	o.WriteByte(byte((x.Value >> 8) & 0xFF))
	o.WriteByte(byte((x.Value >> 16) & 0xFF))
	o.WriteByte(byte((x.Value >> 24) & 0xFF))
}

type VkEnum struct {
	Name   string
	Values []VkEnumValue
}

func (x VkEnum) GetDigestable(o *bytes.Buffer) {
	o.WriteString(x.Name)
	MakeDigestable(o, x.Values...)
}

type VkFunctionArg struct {
	Name string
	Type string
}

func (a VkFunctionArg) String() string {
	return fmt.Sprint(a.Type, " ", a.Name)
}
func (a VkFunctionArg) GetDigestable(o *bytes.Buffer) {
	o.WriteString(a.Name)
	o.WriteString(a.Type)
}

type VkFunctionPointer struct {
	Name   string
	Return string
	Args   []VkFunctionArg
}

func (f VkFunctionPointer) HasReturn() bool {
	return f.Return != "void"
}
func (f VkFunctionPointer) String() string {
	return fmt.Sprintf("typedef %s (VKAPI_PTR PFN_%s)(%s)",
		f.Return, f.Name, Join(", ", f.Args...))
}
func (f VkFunctionPointer) GetDigestable(o *bytes.Buffer) {
	o.WriteString(f.Name)
	o.WriteString(f.Return)
	for _, x := range f.Args {
		x.GetDigestable(o)
	}
}

/***************************************
 * Vulkan bindings
 ***************************************/

var re_vkComma = regexp.MustCompile(`\s*,\s*`)

func vkParseBindingArgs(in string) (result []string) {
	for _, x := range re_vkComma.Split(in, -1) {
		result = append(result, x)
	}
	return result
}

var re_VkBinding = regexp.MustCompile(`(?m)^\s*(VK_\w+)\s*\(\s*(.*?)\s*\)\s*$`)

func vkParseBindings(filename Filename, match func(VkBinding)) error {
	return UFS.Scan(filename, re_VkBinding, func(m []string) error {
		binding := VkBinding{
			Args: vkParseBindingArgs(m[1]),
		}
		if err := binding.Kind.Set(m[0]); err == nil {
			match(binding)
		} else {
			return err
		}
		return nil
	})
}

type VulkanBindingsT struct {
	Src      Filename
	Bindings []VkBinding
}

var GetVulkanBindings = MemoizeArg(func(src Filename) *VulkanBindingsT {
	bg := CommandEnv.BuildGraph()
	bg.Create(src)
	vk := &VulkanBindingsT{Src: src}
	return bg.Create(vk, src.Alias()).GetBuildable().(*VulkanBindingsT)
})

func (vk *VulkanBindingsT) Alias() BuildAlias {
	return MakeBuildAlias("Vulkan", vk.Src.Relative(UFS.Root))
}
func (vk *VulkanBindingsT) Build(bc BuildContext) (BuildStamp, error) {
	vk.Bindings = []VkBinding{}
	err := vkParseBindings(vk.Src, func(vb VkBinding) {
		vk.Bindings = append(vk.Bindings, vb)
	})
	if err != nil {
		return BuildStamp{}, err
	}

	LogTrace("vulkan: found %d bindings", len(vk.Bindings))

	return MakeBuildStamp(vk)
}
func (vk *VulkanBindingsT) GetDigestable(o *bytes.Buffer) {
	vk.Src.GetDigestable(o)
	for _, x := range vk.Bindings {
		x.GetDigestable(o)
	}
}

/***************************************
 * Vulkan headers
 ***************************************/

var re_vkSpace = regexp.MustCompile(`\s+`)

func vkParseFunctionArgs(in string) (result []VkFunctionArg) {
	for _, x := range re_vkComma.Split(in, -1) {
		it := re_vkSpace.Split(x, -1)
		result = append(result, VkFunctionArg{
			Name: it[len(it)-1],
			Type: strings.Join(it[:len(it)-1], " "),
		})
	}
	return result
}

var re_VkFunctionPointer = regexp.MustCompile(`(?m)^\s*typedef\s+(\w+\*?)\s+\(VKAPI_PTR\s+\*PFN_(\w+)\)\((.*?)\)\s*;\s*$`)

func vkParseFunctionPointers(filename Filename, match func(VkFunctionPointer)) error {
	return UFS.Scan(filename, re_VkFunctionPointer, func(m []string) error {
		match(VkFunctionPointer{
			Return: m[0],
			Name:   m[1],
			Args:   vkParseFunctionArgs(m[2]),
		})
		return nil
	})
}

type VulkanHeadersT struct {
	Src Directory

	Headers   FileSet
	Enums     []VkEnum
	Functions []VkFunctionPointer
}

var GetVulkanHeaders = MemoizeArg(func(src Directory) *VulkanHeadersT {
	bg := CommandEnv.BuildGraph()
	bg.Create(src)
	vk := &VulkanHeadersT{Src: src}
	return bg.Create(vk, src.Alias()).GetBuildable().(*VulkanHeadersT)
})

func (vk *VulkanHeadersT) Alias() BuildAlias {
	return MakeBuildAlias("Vulkan", vk.Src.Relative(UFS.Root))
}
func (vk *VulkanHeadersT) Build(bc BuildContext) (BuildStamp, error) {
	vk.Headers = NewFileSet(vk.Src.File("vulkan_core.h"))

	switch CurrentHost().Id {
	case HOST_DARWIN:
		vk.Headers.Append(vk.Src.File("vulkan_macos.h"))
	case HOST_LINUX:
		vk.Headers.Append(vk.Src.File("vulkan_xlib.h"))
	case HOST_WINDOWS:
		vk.Headers.Append(vk.Src.File("vulkan_win32.h"))
	default:
		UnexpectedValue(CurrentHost().Id)
	}

	bc.NeedFile(vk.Headers...)

	vfp := Map(func(f Filename) <-chan VkFunctionPointer {
		result := make(chan VkFunctionPointer)
		go func(f Filename) {
			defer close(result)
			err := vkParseFunctionPointers(f, func(vfp VkFunctionPointer) {
				result <- vfp
			})
			if err != nil {
				panic(err)
			}
		}(f)
		return result
	}, vk.Headers...)

	vk.Functions = []VkFunctionPointer{}
	for _, it := range vfp {
		for x := range it {
			vk.Functions = append(vk.Functions, x)
		}
	}

	LogTrace("vulkan: found %d headers", len(vk.Headers))
	LogTrace("vulkan: found %d functions", len(vk.Functions))

	return MakeBuildStamp(vk)
}
func (vk *VulkanHeadersT) GetDigestable(o *bytes.Buffer) {
	vk.Src.GetDigestable(o)
	vk.Headers.GetDigestable(o)
	for _, x := range vk.Functions {
		x.GetDigestable(o)
	}
}

/***************************************
 * Vulkan Interface
 ***************************************/
type VkExtension struct {
	Name      string
	Foreign   StringSet
	Requires  StringSet
	Aliases   []int
	Functions []int
}

func (ext VkExtension) GetDigestable(o *bytes.Buffer) {
	o.WriteString(ext.Name)
	ext.Foreign.GetDigestable(o)
	ext.Requires.GetDigestable(o)
	tmp := [binary.MaxVarintLen64]byte{}
	for _, x := range ext.Aliases {
		len := binary.PutUvarint(tmp[:], uint64(x))
		o.Write(tmp[:len])
	}
	for _, x := range ext.Functions {
		len := binary.PutUvarint(tmp[:], uint64(x))
		o.Write(tmp[:len])
	}
}

type VkFunction struct {
	Requires string
	Version  string
	*VkFunctionPointer
}

func (fn VkFunction) GetDigestable(o *bytes.Buffer) {
	o.WriteString(fn.Requires)
	o.WriteString(fn.Version)
	if fn.VkFunctionPointer != nil {
		fn.VkFunctionPointer.GetDigestable(o)
	}
}

type VkFunctionAlias struct {
	From, To int
	Version  string
}

func (fn VkFunctionAlias) GetDigestable(o *bytes.Buffer) {
	var len int
	tmp := [binary.MaxVarintLen64]byte{}

	len = binary.PutUvarint(tmp[:], uint64(fn.From))
	o.Write(tmp[:len])

	len = binary.PutUvarint(tmp[:], uint64(fn.To))
	o.Write(tmp[:len])

	o.WriteString(fn.Version)
}

type VulkanInterfaceT struct {
	BindingsFile Filename
	IncludeDir   Directory

	Headers       FileSet
	Versions      StringSet
	EnumTypes     []VkEnum
	ExportedFuncs []VkFunction
	GlobalFuncs   []VkFunction
	InstanceFuncs []VkFunction
	InstanceExts  []VkExtension
	InstanceBwds  []VkFunctionAlias
	DeviceFuncs   []VkFunction
	DeviceExts    []VkExtension
	DeviceBwds    []VkFunctionAlias
}

func (vk *VulkanInterfaceT) GetHeaders() *VulkanHeadersT {
	return GetVulkanHeaders(vk.IncludeDir)
}
func (vk *VulkanInterfaceT) GetBindings() *VulkanBindingsT {
	return GetVulkanBindings(vk.BindingsFile)
}

var GetVulkanInterface = MemoizeArgs2(func(includeDir Directory, bindingsFile Filename) *VulkanInterfaceT {
	bg := CommandEnv.BuildGraph()
	vk := &VulkanInterfaceT{IncludeDir: includeDir, BindingsFile: bindingsFile}
	return bg.Create(vk,
		vk.GetHeaders().Alias(),
		vk.GetBindings().Alias()).
		GetBuildable().(*VulkanInterfaceT)
})

func (vk *VulkanInterfaceT) Alias() BuildAlias {
	return MakeBuildAlias("Vulkan", "Interface")
}
func (vk *VulkanInterfaceT) Build(bc BuildContext) (BuildStamp, error) {
	vkBindings := vk.GetBindings()
	vkHeaders := vk.GetHeaders()

	vk.Headers = vkHeaders.Headers

	funcPointerByName := make(map[string]int, len(vkHeaders.Functions))
	for i, x := range vkHeaders.Functions {
		funcPointerByName[x.Name] = i
	}

	getFuncPointerByName := func(name string) *VkFunctionPointer {
		if i, ok := funcPointerByName[name]; ok {
			return &vkHeaders.Functions[i]
		} else {
			LogVerbose("vulkan: function not found: %s", name)
			return nil
		}
	}

	extensionFuncByName := make(map[string]int)

	instanceExtByName := make(map[string]int)
	getInstanceExtByName := func(name string) *VkExtension {
		if i, ok := instanceExtByName[name]; ok {
			return &vk.InstanceExts[i]
		} else {
			panic(fmt.Errorf("vulkan instance extension not found: %s", name))
		}
	}

	deviceExtByName := make(map[string]int)
	getDeviceExtByName := func(name string) *VkExtension {
		if i, ok := deviceExtByName[name]; ok {
			return &vk.DeviceExts[i]
		} else {
			LogVerbose("vulkan: device extension not found: %s", name)
			return nil
		}
	}

	vk.Versions = NewStringSet()
	vk.EnumTypes = vkHeaders.Enums
	vk.ExportedFuncs = []VkFunction{}
	vk.GlobalFuncs = []VkFunction{}
	vk.InstanceFuncs = []VkFunction{}
	vk.InstanceExts = []VkExtension{}
	vk.InstanceBwds = []VkFunctionAlias{}
	vk.DeviceFuncs = []VkFunction{}
	vk.DeviceExts = []VkExtension{}
	vk.DeviceBwds = []VkFunctionAlias{}

	for _, x := range vkBindings.Bindings {
		LogVeryVerbose("%v(%v)", x.Kind, Join(", ", x.Args))
		switch x.Kind {
		case VK_INSTANCE_LEVEL_EXTENSION:
			instanceExtByName[x.Args[0]] = len(vk.InstanceExts)
			vk.InstanceExts = append(vk.InstanceExts, VkExtension{
				Name:     x.Args[0],
				Requires: x.Args[1:],
			})
		case VK_DEVICE_LEVEL_EXTENSION:
			deviceExtByName[x.Args[0]] = len(vk.DeviceExts)

			instanceExts := NewStringSet()
			deviceExts := NewStringSet()
			for _, ext := range x.Args[1:] {
				if _, ok := instanceExtByName[ext]; ok {
					instanceExts.Append(ext)
				} else {
					deviceExts.Append(ext)
				}
			}

			vk.DeviceExts = append(vk.DeviceExts, VkExtension{
				Name:     x.Args[0],
				Foreign:  instanceExts,
				Requires: deviceExts,
			})
		case VK_EXPORTED_FUNCTION:
			vk.ExportedFuncs = append(vk.ExportedFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_GLOBAL_LEVEL_FUNCTION:
			vk.GlobalFuncs = append(vk.GlobalFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_INSTANCE_LEVEL_FUNCTION:
			vk.Versions.AppendUniq(x.Args[1])
			extensionFuncByName[x.Args[0]] = len(vk.InstanceFuncs)
			vk.InstanceFuncs = append(vk.InstanceFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
				Version:           x.Args[1],
			})
		case VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION:
			instanceExt := getInstanceExtByName(x.Args[1])
			instanceExt.Functions = append(instanceExt.Functions, len(vk.InstanceFuncs))
			extensionFuncByName[x.Args[0]] = len(vk.InstanceFuncs)
			vk.InstanceFuncs = append(vk.InstanceFuncs, VkFunction{
				Requires:          x.Args[1],
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY:
			instanceExt := getInstanceExtByName(x.Args[4])
			instanceExt.Aliases = append(instanceExt.Aliases, len(vk.InstanceBwds))
			vk.InstanceBwds = append(vk.InstanceBwds, VkFunctionAlias{
				From:    extensionFuncByName[x.Args[2]],
				To:      extensionFuncByName[x.Args[3]],
				Version: fmt.Sprintf("VK_VERSION_%s_%s", x.Args[0], x.Args[1]),
			})
		case VK_DEVICE_LEVEL_FUNCTION:
			vk.Versions.AppendUniq(x.Args[1])
			extensionFuncByName[x.Args[0]] = len(vk.DeviceFuncs)
			vk.DeviceFuncs = append(vk.DeviceFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
				Version:           x.Args[1],
			})
		case VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION:
			deviceExt := getDeviceExtByName(x.Args[1])
			deviceExt.Functions = append(deviceExt.Functions, len(vk.DeviceFuncs))
			extensionFuncByName[x.Args[0]] = len(vk.DeviceFuncs)
			vk.DeviceFuncs = append(vk.DeviceFuncs, VkFunction{
				Requires:          x.Args[1],
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY:
			if deviceExt := getDeviceExtByName(x.Args[4]); deviceExt != nil {
				deviceExt.Aliases = append(deviceExt.Aliases, len(vk.InstanceBwds))
			}
			vk.DeviceBwds = append(vk.DeviceBwds, VkFunctionAlias{
				From:    extensionFuncByName[x.Args[2]],
				To:      extensionFuncByName[x.Args[3]],
				Version: fmt.Sprintf("VK_VERSION_%s_%s", x.Args[0], x.Args[1]),
			})
		default:
			UnexpectedValue(x.Kind)
		}
	}

	LogTrace("vulkan: found %d versions", len(vk.Versions))
	LogTrace("vulkan: found %d enum types", len(vk.EnumTypes))
	LogTrace("vulkan: found %d exported functions", len(vk.ExportedFuncs))
	LogTrace("vulkan: found %d global functions", len(vk.GlobalFuncs))
	LogTrace("vulkan: found %d instance functions", len(vk.InstanceFuncs))
	LogTrace("vulkan: found %d instance extensions", len(vk.InstanceExts))
	LogTrace("vulkan: found %d device functions", len(vk.DeviceFuncs))
	LogTrace("vulkan: found %d device extensions", len(vk.DeviceExts))

	return MakeBuildStamp(vk)
}
func (vk *VulkanInterfaceT) GetDigestable(o *bytes.Buffer) {
	vk.IncludeDir.GetDigestable(o)
	vk.BindingsFile.GetDigestable(o)
	vk.Headers.GetDigestable(o)
	vk.Versions.GetDigestable(o)
	MakeDigestable(o, vk.EnumTypes...)
	MakeDigestable(o, vk.ExportedFuncs...)
	MakeDigestable(o, vk.GlobalFuncs...)
	MakeDigestable(o, vk.InstanceFuncs...)
	MakeDigestable(o, vk.InstanceExts...)
	MakeDigestable(o, vk.InstanceBwds...)
	MakeDigestable(o, vk.DeviceFuncs...)
	MakeDigestable(o, vk.DeviceExts...)
	MakeDigestable(o, vk.DeviceBwds...)
}
