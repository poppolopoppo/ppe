# frozen_string_literal: true



require_once '../Core/Environment.rb'
require_once '../Core/Target.rb'

require_once '../Utils/BFFFile.rb'
require_once '../Utils/Checksum.rb'
require_once '../Utils/Log.rb'
require_once '../Utils/Options.rb'
require_once '../Utils/Prerequisite.rb'

require 'set'

module Build

    persistent_switch(:DeoptimizeWithToken, 'Deoptimize TU when FASTBUILD_DEOPTIMIZE_OBJECT found')
    persistent_switch(:LightCache, 'Experimental cache support using command line analysis')

    make_command(:bff, 'BFF generator') do |&namespace|
        bff_output = Build.bff_output

        source = BFF::Source.new(bff_output.filename, minify: Build.Minify)

        source.comment!("BFF generated by %s v%s", File.basename(Build::Script), VERSION)
        source.func!('Settings') do
            set!('RootPath', $WorkspacePath)
            set!('CachePath', $CachePath) if Build.Cache
            #set!('Environment', [
            #    "TMP=#{$TemporaryPath}",
            #    "TEMP=#{$TemporaryPath}" ])
        end

        modified_fileslist_path = BFF.modified_fileslist_path

        source.comment!('Global invariants')
        source.set!('CompilerOutputKeepBaseExtension', false)
        source.set!('DeoptimizeWritableFilesWithToken', Build.DeoptimizeWithToken)
        source.set!('LinkerVerboseOutput', true)
        source.set!('UnityInputIsolateListFile', modified_fileslist_path)

        namespace = namespace[] # <=> .call() => evaluate lambda to defer namespace instantiation

        BFF.make_targets(source, Build.fetch_environments(), namespace)

        source.export_ifn?(bff_output)

        Log.display("generated BFF: %s", bff_output)
    end

    make_persistent_file(:bff_output) do
        ext = File.extname(Build::Script)
        File.join($OutputPath, File.basename(Build::Script, ext) << '.bff')
    end
    make_persistent_file(:modified_fileslist_output) do
        BFF.modified_fileslist_path
    end

    module BFF

        def self.make_targets(bff, environments, namespace)
            Assert.expect(namespace, Namespace)

            targets = namespace.all.dup

            environments.each do |env|
                Assert.expect(env, Environment)
                bff.comment!("Environment <%s>", env.family)

                bff.source.scope!() do
                    targets.each do |target|
                        target_alias = BFF.make_target_alias(env, target)
                        bff.comment!("Target <%s> '%s'", target.type, target_alias)

                        expanded = env.expand(target)

                        case env.target_artifact_type(target)
                        when :headers
                            BFF.make_headers(bff, env, target, target_alias, expanded)
                        when :executable
                            BFF.make_executable(bff, env, target, target_alias, expanded)
                        when :shared
                            BFF.make_shared(bff, env, target, target_alias, expanded)
                        when :library
                            BFF.make_library(bff, env, target, target_alias, expanded)
                        else
                            Log.fatal 'unsupported target type <%s>', target.type
                        end
                    end
                end
            end

            bff.comment!('Generate aliases for all target-platform-config')

            Build.each_build_aliases(environments, targets) do |alias_name, alias_targets|
                Assert.expect(alias_name, String)
                Assert.expect(alias_targets, Array)

                next if alias_targets.empty? # already defined

                Log.debug('BFF: alias <%s> = [%s]', alias_name, alias_targets.join(','))

                bff.func!('Alias', alias_name) do
                    set!('Targets', alias_targets)
                end
            end
        end

        def self.make_target_alias(env, target)
            return "#{target.abs_path}-#{env.family}"
        end

        def self.make_headers(bff, env, target, target_alias, expanded)
            bff.func!('Alias', target_alias) do
                set!('Targets', env.source_path(target.extra_files) + env.source_path(target.libraries.data))
            end
        end

        def self.make_library(bff, env, target, target_alias, expanded)
            return BFF.make_target_base(bff, env, target, target_alias, expanded, false)
        end

        def self.make_executable(bff, env, target, target_alias, expanded)
            BFF.make_deliverable(bff, env, target, target_alias, expanded, 'Executable')
        end
        def self.make_shared(bff, env, target, target_alias, expanded)
            BFF.make_deliverable(bff, env, target, target_alias, expanded, 'DLL')
        end

        def self.make_deliverable(bff, env, target, target_alias, expanded, func)
            libraries = []
            libraries << BFF.make_target_base(bff, env, target, target_alias+'-Lib', expanded, true)

            target.expand_units(expanded, env) do |unit, facet|
                libraries << BFF.make_target_unit(bff, env, target, target_alias, facet, unit)
            end

            bff.func!(func, target_alias) do
                using!(expanded.compiler.name.to_s+'_Details')

                prebuilds = []
                target.all_dependencies do |(dep, visibility)|
                    next if dep.headers?
                    case visibility
                    when :public, :private
                        next if dep.headers?
                        libraries << BFF.make_target_alias(env, dep)
                    when :runtime
                        (env.target_dynamic_link?(dep) ? prebuilds : libraries) << BFF.make_target_alias(env, dep)
                    else
                        Assert.unexpected(visibility)
                    end
                end

                set!('Libraries', libraries)
                set!('PreBuildDependencies', prebuilds)
                set!('LinkerOutput', env.target_artifact_path(target))

                facet!(expanded, :@linkerOptions)
            end
        end

        def self.make_target_unit(bff, env, target, target_alias, expanded, unit)
            compiler_details = BFF.make_compiler_details(bff, expanded.compiler)

            unit_source = unit.var_path+'_Source'
            bff.once?(unit_source) do
                bff.comment!('Unit source details for <%s>', unit.var_path)
                bff.struct!(unit_source) do
                    set!('CompilerInputFilesRoot', env.source_path(unit.source_path))
                    set!('CompilerInputFiles', env.source_path(unit.source_files))
                end
            end

            artifactName = "#{target_alias}-#{unit.name}"
            bff.func!('ObjectList', artifactName) do
                using!(compiler_details)
                using!(unit_source)
                set!('CompilerOutputPath', env.intermediate_path(unit.abs_path))
                set!('Hidden', true)
                facet!(expanded, :@compilerOptions)
            end

            return artifactName
        end

        def self.make_target_base(bff, env, target, target_alias, expanded, hidden)
            compiler_details = BFF.make_compiler_details(bff, expanded.compiler)

            if Build.PCH and target.pch?
                target_pch_header = target.pch_header
                target_pch_source = target.pch_source
            else
                target_pch_header, target_pch_source = nil
            end

            target_source = target.var_path+'_Source'
            bff.once?(target_source) do
                bff.comment!('Target source details for <%s>', target.abs_path)

                target_unity = nil
                if Build.Unity and not target.tag?(:nounity) and target.rel_glob_path and target.glob_patterns
                    target_unity = target.var_path+'_Unity'
                    bff.func!('Unity', target_unity) do
                        set!('UnityNumFiles', target.unity_num_files)
                        if target_pch_header
                            set!('UnityPCH', target.rel_pch_header)
                        end
                        glob_path = env.source_path(target.glob_path)
                        set!('UnityInputPath', glob_path)
                        set!('UnityInputPattern', target.glob_patterns)
                        set!('UnityInputExcludedFiles', env.relative_path(glob_path, target.unity_excluded_files))
                        set!('UnityOutputPath', File.join($UnitiesPath, File.dirname(target.abs_path)))
                        set!('UnityOutputPattern', "#{target.name}_*_of_#{target.unity_num_files}.cpp")
                        set!('Hidden', true)
                    end
                end

                bff.struct!(target_source) do
                    set!('CompilerInputFilesRoot', env.source_path(target.source_path))
                    set!('CompilerInputFiles', env.source_path(target.source_files), force: true) # force for append bellow
                    if target_unity
                        append!('CompilerInputFiles', env.source_path(target.isolated_files))
                        set!('CompilerInputUnity', target_unity)
                    elsif target.rel_glob_path and target.glob_patterns
                        glob_path = env.source_path(target.glob_path)
                        set!('CompilerInputPath', glob_path)
                        set!('CompilerInputPattern', target.glob_patterns)
                        set!('CompilerInputExcludedFiles', env.relative_path(glob_path, target.excluded_files))
                    end
                    if target_pch_source
                        set!('PCHInputFile', env.source_path(target_pch_source))
                    end
                end
            end

            case env.config.link
            when :static
                link_library_objects = target.executable?
            when :dynamic
                link_library_objects = true
            else
                Assert.not_implemented
            end

            artifactName = target_alias
            bff.func!(link_library_objects ? 'ObjectList' : 'Library', artifactName) do
                using!(compiler_details)
                using!(target_source)

                set!('CompilerOutputPath', env.intermediate_path(target.abs_path))
                facet!(expanded, :@compilerOptions)
                facet!(expanded, :@preprocessorOptions) if expanded.preprocessor?

                if target_pch_source
                    set!('PCHOutputFile', env.output_path(target_pch_source, :pch))
                    facet!(expanded, PCHOptions: :@pchOptions)
                end

                unless link_library_objects
                    privateDeps = []
                    target.all_private_dependencies do |dep|
                        next if dep.headers?
                        privateDeps << BFF.make_target_alias(env, dep)
                    end
                    set!('LibrarianAdditionalInputs', privateDeps)
                    set!('LibrarianOutput', env.output_path(target.abs_path, :library))
                    facet!(expanded, :@librarianOptions)
                end

                set!('Hidden', hidden)
            end

            return artifactName
        end

        def self.make_compiler_details(bff, compiler)
            compiler_details = compiler.name.to_s+'_Details'
            bff.once?(compiler.name) do
                func!('Compiler', compiler.name.to_s) do
                    set!('Executable', compiler.executable)
                    set!('ExtraFiles', compiler.extra_files) if compiler.extra_files
                    set!('CompilerFamily', compiler.family.to_s) if compiler.family
                    set!('UseLightCache_Experimental', Build.LightCache && compiler.tag?(:lightcache))
                end
                struct!(compiler_details) do
                    set!('Compiler', compiler.name.to_s)
                    set!('Librarian', compiler.librarian) if compiler.librarian
                    set!('Linker', compiler.linker) if compiler.linker
                    set!('CompilerOutputExtension', compiler.ext_for(:obj))
                end
            end
            return compiler_details
        end

    end #~ BFF

end #~ Build
