# frozen_string_literal: true

require_once '../Common.rb'
require_once '../Core/Environment.rb'
require_once '../Core/Target.rb'
require_once '../Utils/Log.rb'
require_once '../Utils/Options.rb'
require_once '../Utils/Prerequisite.rb'

require_once '../Commands/FASTBuild.rb'

require 'fileutils'
require 'find'
require 'pathname'
require 'set'

module Build

    PCH_MINREFNUM = 20 # # of sources include for a projec header -> PCH
    PCH_THRESHOLD = 98 / 100.0 # % of sources include for a project header -> PCH

    make_command(:genpch, 'Generate precompiled headers') do |&namespace|
        environments = Build.fetch_environments
        targets = namespace[].select(*Build::Args)

        resolver = PCH::Resolver.new

        pch_to_generate = []
        targets.each do |target|
            next if target.pch_header.nil?

            pch_header = File.join($SourcePath, target.pch_header)
            pch_generated = Pathname.new(pch_header).sub_ext('.generated.h').to_s

            next unless File.exist?(pch_generated)

            resolver.add_pch_include(pch_header)
            resolver.add_pch_include(pch_generated)

            pch_to_generate << [ target, pch_generated ]

            Log.log 'PCH: clear generated file "%s"', pch_generated
            File.write(pch_generated, '')
        end

        PCH.preprocess()

        includes = PCH::IncludeParser.new(resolver)

        pch_to_generate.each_with_index do |(target, pch_generated), target_i|
            target_status = "Building PCH for <#{target}> #{target_i+1}/#{pch_to_generate.length}"
            Log.pin(target_status)

            Log.log 'PCH: generate precompiled for <%s>', target.abs_path

            pch_deps = {}
            environments.each_with_index do |env, env_i|
                config = "BUILD_#{env.varname}"
                artifact = "#{target.abs_path}-#{env.family}"

                Log.pin(target_status + " -> #{config} #{env_i+1}/#{environments.length}")

                env.facet.externPaths.each do |path|
                    resolver.extern_path!(path)
                end
                env.facet.systemPaths.each do |path|
                    resolver.system_path!(path)
                end

                includes.parse_dir(env.source_path(target.source_path))

                deps = PCH.dependencies(env, artifact, resolver)

                pch_deps[config] = deps.keep_only_if_above!(PCH_THRESHOLD)
            end

            Log.clear_pin

            global_deps = nil
            pch_deps.each do |config, deps|
                if global_deps.nil?
                    global_deps = PCH::Dependencies.new(resolver)
                    global_deps.concat!(deps)
                else
                    global_deps.union!(deps)
                end
            end

            pch_deps.each do |config, deps|
                deps.exclusion!(global_deps)
            end

            PCH.generate_pch(pch_generated, global_deps, pch_deps)
        end
    end

    module PCH

        def self.preprocess()
            Log.info 'PCH: preprocessing all targets...'
            FBuild.run('-preprocess', '-nounity', 'All', quiet: !Log.verbose?)
        end

        RE_otherfile = /File\s(.*)$/i
        RE_header = /File\s(.*\.h)$/i
        RE_source = /File\s(.*\.(c|cc|cpp))$/i
        def self.dependencies(env, target, resolver)
            Log.log 'PCH: parsing target <%s> dependencies', target

            deps = PCH::Dependencies.new(resolver)

            re_object = /Object\s(.*\.#{env.compiler.ext_obj[1..-1]})$/i

            FBuild.run('-showdeps', target, wait: false) do |line|
                if m = line.match(RE_header)
                    deps.header(m[1])
                elsif m = line.match(re_object)
                    deps.object(m[1])
                elsif m = line.match(RE_source)
                    deps.source(m[1])
                elsif m = line.match(RE_otherfile)
                    deps.header(m[1]) if File.extname(m[1]).empty?
                end
            end

            Log.log 'PCH: target <%s> has %d system / %d project headers', target, deps.systemHeaders.length, deps.projectHeaders.length

            return deps
        end

        def self.generate_pch(fname, global, configs)
            pch = MemFile.new(fname)
            pch.puts!('/*')
            pch.puts!('** Generated by %s v%s', Build::Script, Build::VERSION)
            pch.puts!('*/')

            pch.puts!('#ifdef PLATFORM_%s', os_name.to_s.upcase)

            pch.puts!('// Global system includes (%d)', global.systemHeaders.length)
            PCH.make_include(pch, global.systemHeaders, system: true)
            pch.puts!('// Global project includes (%d)', global.projectHeaders.length)
            PCH.make_include(pch, global.projectHeaders, system: false)

            configs.each do |name, deps|
                unless deps.systemHeaders.empty? and deps.projectHeaders.empty?
                    pch.puts!('#ifdef %s', name)
                    pch.puts!('// system includes (%d)', deps.systemHeaders.length)
                    PCH.make_include(pch, deps.systemHeaders, system: true)
                    pch.puts!('// project includes (%d)', deps.projectHeaders.length)
                    PCH.make_include(pch, deps.projectHeaders, system: false)
                    pch.puts!('#endif // %s', name)
                end
            end

            pch.puts!('#endif //! PLATFORM_%s', os_name.to_s.upcase)

            pch.write_to_disk

            Log.info 'PCH: wrote "%s"', fname
        end

        def self.make_include(pch, refs, system: false)
            if system
                quote_l, quote_r = '<', '> '
            else
                quote_l, quote_r = '"', '" '
            end
            refs.each do |filename, refcount|
                pch.print!('#include ')
                pch.print!(quote_l)
                pch.print!(filename)
                pch.print!(quote_r)
                pch.puts!('// %d refs', refcount)
            end
        end

        class IncludeParser
            RE_SYSTEM_INCLUDE=/#\s*include\s+<(.*?)>/
            attr_reader :resolver, :includes
            def initialize(resolver)
                @resolver = resolver
                @includes = {}
                @visiteds = Set.new
            end
            def parse_dir(path)
                return unless @visiteds.add?(path)
                Find.find(path) do |entry|
                    parse_file(entry) if entry =~ /\.(h|cpp|cc|c)$/i
                end
            end
            def parse_file(filename)
                return unless @visiteds.add?(filename)
                File.open(filename, 'r') do |fd|
                    fd.each do |line|
                        m = line.match(RE_SYSTEM_INCLUDE)
                        next unless m
                        @resolver.add_system_include(m[1])
                    end
                end
            end
        end #~ IncludeParser

        class Resolver
            attr_reader :headers, :systemPaths
            def initialize()
                @headers = {}
                @includes = {}
                @externPaths = Set.new
                @systemPaths = Set.new
                @projectPaths = Set.new
                @sourcePath = Pathname.new($SourcePath)
                @sourceGlob = File.join($SourcePath, '**')
            end

            def project_path!(path) @projectPaths << Pathname.new(path).expand_path end
            def extern_path!(path) @externPaths <<  Pathname.new(path).expand_path end
            def system_path!(path) @systemPaths <<  Pathname.new(path).expand_path end

            def merge_from!(other)
                other.headers.each do |header, info|
                    @headers[header] = info
                end
                other.includes.each do |header, fullpath|
                    @includes[header] = fullpath
                end
                return self
            end

            def add_pch_include(header)
                key = File.basename(header)
                @includes[key] = header
                @headers[header] = [ :ignored, nil ]
                Log.debug 'PCH: ignoring precompiled header "%s"', header
            end

            def add_system_include(header)
                key = header
                unless @includes.include?(key)
                    loop do
                        @systemPaths.each do |systemPath|
                            fullpath = File.join(systemPath, header)
                            if File.exist?(fullpath)
                                @headers[fullpath] = [ :system, key ]
                                @includes[key] = fullpath
                                return
                            end
                        end
                        break if File.extname(header) == '.h'
                        header << '.h'
                    end
                    @includes[key] = :none
                    Log.log 'PCH: ignoring unkown system header <%s>', header
                end
            end

            def from_fullpath(header, allow_resolve: false)
                info = @headers[header]
                return info if info

                path = Pathname.new(header).expand_path
                info = @headers[path.to_s]
                if info
                    @headers[header] = info
                    return info
                end

                if path.fnmatch?(@sourceGlob)
                    path = path.relative_path_from(@sourcePath)
                    info = [ :project, path.to_s ]
                elsif allow_resolve
                    @systemPaths.each do |systemPath|
                        if path.fnmatch?(File.join(systemPath, '**'))
                            path = path.relative_path_from(systemPath)
                            info = [ :system, path.to_s ]
                            break
                        end
                    end
                else
                    info = [ :ignored, nil ]
                end

                @headers[header] = info if info
                return info
            end

        end #~ Resolver

        class RefCounter
            attr_reader :data
            def initialize()
                @data = Hash.new(0)
            end

            def empty?() @data.empty? end
            def length() @data.length end
            def include?(filename) @data.include?(filename) end

            def files() @data.keys end
            def each(&block) @data.each(&block) end

            def [](filename) @data[filename] end
            def []=(filename, refcount) add(filename, refcount) end
            def add(filename, refcount=1)
                @data[filename] += refcount
            end

            def concat!(other)
                other.data.each do |filename, refcount|
                    @data[filename] = refcount
                end
                return self
            end
            def union!(other)
                @data.delete_if do |filename, refcount|
                    n = other.data[filename]
                    if n > 0
                        @data[filename] = n if n > refcount
                        false
                    else
                        true
                    end
                end
                return self
            end
            def exclusion!(other)
                @data.delete_if do |filename, refcount|
                    other.data.include?(filename)
                end
                return self
            end

            def filter!(includes)
                @data.delete_if do |filename, refcount|
                    not includes
                end
                @data = new_data
                return self
            end
            def threshold!(delete_if_under_n)
                @data.delete_if do |filename, refcount|
                    refcount < delete_if_under_n ||
                        refcount < PCH_MINREFNUM
                end
                return self
            end

        end #~ RefCounter

        class Dependencies
            attr_reader :resolver
            attr_reader :objects, :sources
            attr_reader :systemHeaders, :projectHeaders
            def initialize(resolver)
                @resolver = resolver
                @systemHeaders = RefCounter.new
                @projectHeaders = RefCounter.new
                @sources = Set.new
                @objects = Set.new
            end
            def object(filename)
                filename = Pathname.new(filename).expand_path
                @objects << filename
            end
            def source(filename)
                filename = Pathname.new(filename).expand_path
                @sources << filename
            end
            def header(filename, refcount: 1)
                type, path = *@resolver.from_fullpath(filename)
                case type
                when :ignored
                    #Log.warning 'PCH: ignored include <%s>', File.basename(filename)
                when :system
                    @systemHeaders.add(path, refcount)
                when :project
                    @projectHeaders.add(path, refcount) unless path =~ /-(inl|impl)\.h$/i
                else
                    Log.fatal 'unsupported header type <%s>', type
                end
                return path
            end
            def concat!(other)
                @systemHeaders.concat!(other.systemHeaders)
                @projectHeaders.concat!(other.projectHeaders)
                return self
            end
            def union!(other)
                @systemHeaders.union!(other.systemHeaders)
                @projectHeaders.union!(other.projectHeaders)
                return self
            end
            def exclusion!(other)
                @systemHeaders.exclusion!(other.systemHeaders)
                @projectHeaders.exclusion!(other.projectHeaders)
                return self
            end

            def keep_only_if_above!(percent=0.95)
                @projectHeaders.threshold!((@sources.length * percent).ceil)
                return self
            end
        end #~ Dependencies

    end #~ PCH

end #~ Build
