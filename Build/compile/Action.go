package compile

import (
	//lint:ignore ST1001 ignore dot imports warning
	. "build/utils"
	"fmt"
	"strings"
)

var LogAction = NewLogCategory("Action")

/***************************************
 * ActionFlags
 ***************************************/

type ActionFlags struct {
	CacheMode  CacheModeType
	CachePath  Directory
	ShowCmds   BoolVar
	ShowFiles  BoolVar
	ShowOutput BoolVar
}

func (x *ActionFlags) Flags(cfv CommandFlagsVisitor) {
	cfv.Persistent("CacheMode", "use input hashing to store/retrieve action outputs", &x.CacheMode)
	cfv.Persistent("CachePath", "set path used to store cached actions", &x.CachePath)
	cfv.Variable("ShowCmds", "print executed compilation commands", &x.ShowCmds)
	cfv.Variable("ShowFiles", "print file accesses for external commands", &x.ShowFiles)
	cfv.Variable("ShowOutput", "always show compilation commands output", &x.ShowOutput)
}

var GetActionFlags = NewCommandParsableFlags(&ActionFlags{
	CacheMode:  CACHE_NONE,
	CachePath:  UFS.Cache,
	ShowCmds:   INHERITABLE_FALSE,
	ShowFiles:  INHERITABLE_FALSE,
	ShowOutput: INHERITABLE_FALSE,
})

/***************************************
 * Action
 ***************************************/

type Action interface {
	GetAction() *ActionRules
	DependsOn(actions ...Action)
	Buildable
	fmt.Stringer
}

type ActionRules struct {
	Target       TargetAlias
	Payload      PayloadType
	Executable   Filename
	WorkingDir   Directory
	Environment  ProcessEnvironment
	CacheMode    CacheModeType
	Inputs       FileSet
	Outputs      FileSet
	Exports      FileSet
	Extras       FileSet
	Arguments    StringSet
	Dependencies BuildAliases
}

func (x *ActionRules) Alias() BuildAlias {
	return MakeBuildAlias("Action", x.Outputs.Join(";"))
}
func (x *ActionRules) Build(bc BuildContext) error {
	flags := GetActionFlags()

	// inputs are dynamic dependencies, since they can be generated by another action
	if err := bc.NeedFile(x.Inputs...); err != nil {
		return err
	}

	// consolidate output files
	outputFiles := FileSet{}
	outputFiles.AppendUniq(x.Outputs...) // some entries could be shared between the 3 sets
	outputFiles.AppendUniq(x.Exports...)
	outputFiles.AppendUniq(x.Extras...)
	outputFiles.Sort()

	// check if we can read action cache
	var cacheKey ActionCacheKey
	needToRunProcess := true
	if flags.CacheMode.HasRead() && x.CacheMode.HasRead() {
		var err error
		if cacheKey, err = GetActionCache().CacheRead(x, outputFiles); err == nil {
			needToRunProcess = false // cache-hit
		}
	}

	// limit number of concurrent external processes with MakeGlobalWorkerFuture()
	if needToRunProcess {
		future := MakeGlobalWorkerFuture(func() (FileSet, error) {
			// check if we should log executed command-line
			if flags.ShowCmds.Get() {
				LogForwardf("%q %v", x.Executable, MakeStringer(func() string {
					return fmt.Sprint("\"", strings.Join(x.Arguments, "\" \""), "\"")
				}))
			}

			// run the external process with action command-line and file access hooking
			var readFiles FileSet
			return readFiles, RunProcess(x.Executable, x.Arguments,
				OptionProcessEnvironment(x.Environment),
				OptionProcessWorkingDir(x.WorkingDir),
				OptionProcessCaptureOutputIf(flags.ShowOutput.Get()),
				OptionProcessFileAccess(func(far FileAccessRecord) error {
					if flags.ShowFiles.Get() {
						LogForwardf("%v: [%s]  %s", MakeStringer(func() string {
							return x.Alias().String()
						}), far.Access, far.Path)
					}

					// only file access read/execute: output files could messed with writable mapped system Dll on Windows :'(
					if far.Access.HasRead() && !(far.Access.HasWrite() || far.Access.HasExecute()) {
						if !x.Inputs.Contains(far.Path) && !x.Outputs.Contains(far.Path) {
							readFiles.AppendUniq(far.Path)
						}
					}

					return nil
				}),
				OptionProcessNoSpinner)
		})

		readFiles := future.Join()
		if err := readFiles.Failure(); err != nil {
			return err
		}

		if err := bc.NeedFile(readFiles.Success()...); err != nil {
			return err
		}
	}

	// check if this action should be cached-in
	if flags.CacheMode.HasWrite() && x.CacheMode.HasWrite() &&
		needToRunProcess /* if we compiled this action */ {
		bc.OnBuilt(func(node BuildNode) error {
			// queue a new asynchronous task to avoid blocking the buildgraph
			Assert(func() bool { return GetActionCache().(*actionCache).makeActionKey(x) == cacheKey })
			return GetActionCache().AsyncCacheWrite(node, cacheKey, outputFiles)
		})
	}

	// check that process did write expected files and track them as outputs
	return bc.OutputFile(outputFiles...)
}

func (x *ActionRules) GetAction() *ActionRules { return x }
func (x *ActionRules) DependsOn(actions ...Action) {
	for _, other := range actions {
		x.Dependencies.AppendUniq(other.Alias())
	}
}
func (x *ActionRules) Serialize(ar Archive) {
	ar.Serializable(&x.Target)
	ar.Serializable(&x.Payload)
	ar.Serializable(&x.Executable)
	ar.Serializable(&x.WorkingDir)
	ar.Serializable(&x.Environment)
	ar.Serializable(&x.CacheMode)
	ar.Serializable(&x.Inputs)
	ar.Serializable(&x.Arguments)

	ar.Serializable(&x.Outputs)
	ar.Serializable(&x.Exports)
	ar.Serializable(&x.Extras)

	SerializeSlice(ar, x.Dependencies.Ref())
}
func (x *ActionRules) String() string {
	oss := strings.Builder{}
	fmt.Fprintf(&oss, "%q", x.Executable)
	for _, arg := range x.Arguments {
		fmt.Fprintf(&oss, " %q", arg)
	}
	return oss.String()
}

func makeActionFactory(compiler CompilerAlias, action Action) BuildFactoryTyped[Action] {
	return WrapBuildFactory(func(bi BuildInitializer) (Action, error) {
		rules := action.GetAction()

		// track compiler
		if err := bi.DependsOn(compiler.Alias()); err != nil {
			return nil, err
		}

		// track dependent actions as build dependency and as a member alias list
		if err := bi.DependsOn(rules.Dependencies...); err != nil {
			return nil, err
		}

		// do NOT insert inputs as static dependencies here, this is handled by callee

		// add dependent actions to create output directories
		outputDirs := DirSet{}
		for _, filename := range rules.Outputs {
			outputDirs.AppendUniq(filename.Dirname)
		}
		for _, filename := range rules.Extras {
			outputDirs.AppendUniq(filename.Dirname)
		}

		for _, directory := range outputDirs {
			if _, err := BuildDirectoryCreator(directory).Need(bi); err != nil {
				return nil, err
			}
		}

		return action, nil
	})
}

/***************************************
 * Target Actions
 ***************************************/

type PayloadBuildAliases = [NumPayloadTypes]BuildAliases

type TargetActions struct {
	TargetAlias
	OutputType PayloadType
	Payloads   PayloadBuildAliases
}

func (x *TargetActions) Alias() BuildAlias {
	return MakeBuildAlias("Targets", x.TargetAlias.String())
}
func (x *TargetActions) Build(bc BuildContext) error {
	x.OutputType = PAYLOAD_HEADERS
	x.Payloads = PayloadBuildAliases{}

	unit, err := GetBuildUnit(x.TargetAlias)
	if err != nil {
		return err
	}
	Assert(func() bool { return nil != unit })

	generator := buildActionGenerator{
		Environment:   x.TargetAlias.EnvironmentAlias,
		TargetActions: x,
		BuildContext:  bc,
	}

	if err := generator.CreateActions(unit); err != nil {
		return err
	}

	return nil
}
func (x *TargetActions) Serialize(ar Archive) {
	ar.Serializable(&x.TargetAlias)
	ar.Serializable(&x.OutputType)
	for i := range x.Payloads {
		SerializeSlice(ar, x.Payloads[i].Ref())
	}
}

func (x *TargetActions) GetOutputAliases() BuildAliases {
	return x.Payloads[x.OutputType]
}
func (x *TargetActions) GetOutputActions() (ActionSet, error) {
	return GetBuildActions(x.GetOutputAliases()...)
}

func GetBuildActions(aliases ...BuildAlias) (ActionSet, error) {
	result := make(ActionSet, len(aliases))
	for i, alias := range aliases {
		if action, err := FindGlobalBuildable[Action](alias); err == nil {
			Assert(func() bool { return nil != action })
			result[i] = action
		} else {
			return ActionSet{}, err
		}
	}
	return result, nil
}

func GetTargetActions(target TargetAlias) BuildFactoryTyped[*TargetActions] {
	return MakeBuildFactory(func(bi BuildInitializer) (TargetActions, error) {
		return TargetActions{TargetAlias: target}, bi.NeedBuildable(target.Alias())
	})
}

func ForeachTargetActions(ea EnvironmentAlias, each func(BuildFactoryTyped[*TargetActions]) error, ma ...ModuleAlias) error {
	for _, it := range ma {
		if err := each(GetTargetActions(TargetAlias{EnvironmentAlias: ea, ModuleAlias: it})); err != nil {
			return err
		}
	}
	return nil
}

/***************************************
 * Build Action Generator
 ***************************************/

type buildActionGenerator struct {
	Environment EnvironmentAlias
	*TargetActions
	BuildContext
}

func (x *buildActionGenerator) CreateActions(unit *Unit) error {
	var targetOutputs ActionSet
	x.OutputType = unit.Payload

	customs, err := x.CustomActions(unit, ActionSet{})
	if err != nil {
		return err
	}

	if unit.Payload != PAYLOAD_HEADERS {
		pchs, err := x.PrecompilerHeaderActions(unit, customs)
		if err != nil {
			return err
		}

		x.Payloads[PAYLOAD_PRECOMPILEDHEADER] = pchs.Aliases()

		objs, err := x.ObjectListActions(unit, append(customs, pchs...))
		if err != nil {
			return err
		}

		x.Payloads[PAYLOAD_OBJECTLIST] = objs.Aliases()

		switch unit.Payload {
		case PAYLOAD_EXECUTABLE, PAYLOAD_SHAREDLIB:
			link, err := x.LinkActions(unit, pchs, objs)
			if err != nil {
				return err
			}

			runtimes, err := x.GetOutputActions(unit.RuntimeDependencies...)
			if err != nil {
				return err
			}

			link.DependsOn(runtimes...)

			x.Payloads[unit.Payload] = link.Aliases()
			targetOutputs = link

		case PAYLOAD_STATICLIB:
			lib, err := x.LibrarianActions(unit, pchs, objs)
			if err != nil {
				return err
			}

			x.Payloads[PAYLOAD_STATICLIB] = lib.Aliases()
			targetOutputs = lib

		case PAYLOAD_OBJECTLIST:
			targetOutputs = objs

		default:
			UnexpectedValuePanic(unit.Payload, unit.Payload)
		}

	} else {
		x.Payloads[PAYLOAD_HEADERS] = customs.Aliases()
		targetOutputs = customs
	}

	Assert(func() bool { return x.OutputType == PAYLOAD_HEADERS || len(targetOutputs) > 0 })
	LogVeryVerbose(LogAction, "%q outputs %v payload with %d artifacts%s", unit, unit.Payload, len(targetOutputs),
		MakeStringer(func() string {
			if IsLogLevelActive(LOG_VERYVERBOSE) {
				allActions := ActionSet{}
				if err := targetOutputs.ExpandDependencies(&allActions); err == nil {
					return fmt.Sprintf(" (%d total actions)", len(allActions))
				} else {
					return fmt.Sprint(err)
				}
			}
			return ""
		}))

	return nil
}

func (x *buildActionGenerator) NewActionRules(
	unit *Unit,
	payload PayloadType,
	cacheMode CacheModeType,
	executable Filename,
	workingDir Directory,
	environment ProcessEnvironment,
	inputs, outputs, exports, extras FileSet,
	dependentActions ActionSet,
	arguments ...string) *ActionRules {
	Assert(func() bool { return len(inputs) > 0 })
	Assert(func() bool { return len(outputs) > 0 })

	// perform argument expansion now
	arguments = performArgumentSubstitution(unit, payload, inputs, outputs, arguments...)

	action := &ActionRules{
		Target:       unit.Target,
		Payload:      payload,
		Executable:   executable,
		WorkingDir:   workingDir,
		Environment:  environment,
		Inputs:       inputs,
		Outputs:      outputs,
		Exports:      exports,
		Extras:       extras,
		Arguments:    sanitizeArgumentsForAction(arguments...),
		CacheMode:    cacheMode,
		Dependencies: dependentActions.Aliases(),
	}
	AssertMessage(func() bool { return len(inputs) > 0 }, "%v: no action input present", action.Alias())
	AssertMessage(func() bool { return len(outputs) > 0 }, "%v: no action output present", action.Alias())
	AssertNotIn(action.CacheMode, CACHE_INHERIT)

	if action.CacheMode.HasRead() || action.CacheMode.HasWrite() {
		// exclude locally modified files from caching
		if scm, err := BuildSourceControlModifiedFiles().Need(x.BuildContext); err == nil {
			for _, file := range inputs {
				if scm.ModifiedFiles.Contains(file) {
					LogVerbose(LogAction, "%v: excluded from cache since %q is locally modified")
					action.CacheMode = CACHE_NONE
					break
				}
			}
		}
	}

	return action
}

func (x *buildActionGenerator) NewAction(
	unit *Unit,
	payload PayloadType,
	cacheMode CacheModeType,
	executable Filename,
	workingDir Directory,
	environment ProcessEnvironment,
	inputs, outputs, exports, extras FileSet,
	dependentActions ActionSet,
	arguments ...string) (Action, error) {
	rules := x.NewActionRules(
		unit, payload, cacheMode,
		executable, workingDir, environment,
		inputs, outputs, exports, extras,
		dependentActions, arguments...)
	return rules, x.BuildContext.OutputNode(makeActionFactory(unit.CompilerAlias, rules))
}
func (x *buildActionGenerator) NewSourceDependencyAction(
	compiler Compiler,
	unit *Unit,
	payload PayloadType,
	cacheMode CacheModeType,
	executable Filename,
	workingDir Directory,
	environment ProcessEnvironment,
	inputs, outputs, exports, extras FileSet,
	dependentActions ActionSet,
	arguments ...string) (Action, error) {
	if OnRunCommandWithDetours != nil {
		// platform supports running process with IO detouring
		return x.NewAction(
			unit, payload, cacheMode,
			executable, workingDir, environment,
			inputs, outputs, exports, extras,
			dependentActions, arguments...)
	} else {
		// no support: must rely on compiler support for source dependencies
		rules := x.NewActionRules(
			unit, payload, cacheMode,
			executable, workingDir, environment,
			inputs, outputs, exports, extras,
			dependentActions, arguments...,
		)
		action := compiler.SourceDependencies(rules)
		return action, x.BuildContext.OutputNode(makeActionFactory(compiler.GetCompiler().CompilerAlias, action))
	}
}

func (x *buildActionGenerator) ForEachTargetActions(each func(*TargetActions) error, targets ...TargetAlias) error {
	for _, it := range targets {
		if target, err := GetTargetActions(it).Need(x.BuildContext); err == nil {
			if err := each(target); err != nil {
				return err
			}
		} else {
			return err
		}
	}
	return nil
}
func (x *buildActionGenerator) GetOutputActions(targets ...TargetAlias) (ActionSet, error) {
	result := ActionSet{}
	err := x.ForEachTargetActions(func(ta *TargetActions) error {
		if actions, err := ta.GetOutputActions(); err == nil {
			result = append(result, actions...)
		} else {
			return err
		}
		return nil
	}, targets...)
	return result, err
}

func (x *buildActionGenerator) PrecompilerHeaderActions(unit *Unit, dependencies ActionSet) (ActionSet, error) {
	actions := ActionSet{}
	switch unit.PCH {
	case PCH_DISABLED:
		// nothing to do
	case PCH_MONOLITHIC:
		compiler, err := unit.GetBuildCompiler()
		if err != nil {
			return ActionSet{}, err
		}
		compilerRules := compiler.GetCompiler()
		pchObject := Filename{
			Dirname:  unit.PrecompiledObject.Dirname,
			Basename: unit.PrecompiledObject.Basename + compiler.Extname(PAYLOAD_OBJECTLIST)}

		inputs := FileSet{unit.PrecompiledSource, unit.PrecompiledHeader}
		outputs := FileSet{pchObject}
		exports := FileSet{pchObject}
		extras := FileSet{unit.PrecompiledObject}

		action, err := x.NewSourceDependencyAction(
			compiler,
			unit,
			PAYLOAD_PRECOMPILEDHEADER,
			compiler.AllowCaching(unit, PAYLOAD_PRECOMPILEDHEADER),
			compilerRules.Executable,
			UFS.Root,
			compilerRules.Environment,
			inputs, outputs, exports, extras,
			dependencies,
			unit.PrecompiledHeaderOptions...)
		if err != nil {
			return ActionSet{}, err
		}

		actions.Append(action)
	case PCH_SHARED:
		return ActionSet{}, fmt.Errorf("PCH_SHARED is not supported at the monent")
	default:
		UnexpectedValuePanic(unit.PCH, unit.PCH)
	}
	return actions, nil
}
func (x *buildActionGenerator) CustomActions(unit *Unit, dependencies ActionSet) (ActionSet, error) {
	result := ActionSet{}
	for _, custom := range unit.CustomUnits {
		if actions, err := x.ObjectListActions(&custom.Unit, dependencies); err == nil {
			result.Append(actions...)
		} else {
			return ActionSet{}, err
		}
	}
	return result, nil
}
func (x *buildActionGenerator) ObjectAction(
	unit *Unit, dependencies ActionSet,
	compiler Compiler,
	input, output Filename) (Action, error) {
	compilerRules := compiler.GetCompiler()
	return x.NewSourceDependencyAction(
		compiler,
		unit,
		PAYLOAD_OBJECTLIST,
		compiler.AllowCaching(unit, PAYLOAD_OBJECTLIST),
		compilerRules.Executable,
		UFS.Root,
		compilerRules.Environment,
		FileSet{input}, FileSet{output}, FileSet{output}, FileSet{},
		dependencies,
		unit.CompilerOptions...)
}
func (x *buildActionGenerator) ObjectListActions(unit *Unit, dependencies ActionSet) (ActionSet, error) {
	includeDeps, err := x.GetOutputActions(unit.IncludeDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	compiler, err := unit.GetBuildCompiler()
	if err != nil {
		return ActionSet{}, err
	}

	dependencies = append(dependencies, includeDeps...)
	objs := make(ActionSet, len(unit.SourceFiles))

	for i, input := range unit.SourceFiles {
		output := unit.GetPayloadOutput(compiler, input, PAYLOAD_OBJECTLIST)
		action, err := x.ObjectAction(unit, dependencies, compiler, input, output)
		if err != nil {
			return ActionSet{}, err
		}

		objs[i] = action
	}

	return objs, nil
}
func (x *buildActionGenerator) LibrarianActions(unit *Unit, pchs ActionSet, objs ActionSet) (ActionSet, error) {
	AssertIn(unit.Payload, PAYLOAD_STATICLIB, PAYLOAD_SHAREDLIB)

	compileDeps, err := x.GetOutputActions(unit.CompileDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	compiler, err := unit.GetBuildCompiler()
	if err != nil {
		return ActionSet{}, err
	}

	compilerRules := compiler.GetCompiler()
	dependencies := ActionSet{}
	dependencies.Append(pchs...)
	dependencies.Append(objs...)
	dependencies.Append(compileDeps...)

	inputs := dependencies.GetExportFiles()
	outputs := FileSet{unit.OutputFile}
	exports := FileSet{unit.ExportFile}
	extras := NewFileSet(unit.ExtraFiles...)
	if unit.SymbolsFile.Valid() {
		extras.Append(unit.SymbolsFile)
	}

	lib, err := x.NewAction(
		unit,
		PAYLOAD_STATICLIB,
		compiler.AllowCaching(unit, PAYLOAD_STATICLIB),
		compilerRules.Librarian,
		UFS.Root,
		compilerRules.Environment,
		inputs, outputs, exports, extras,
		dependencies,
		unit.LibrarianOptions...)

	return ActionSet{lib}, err
}
func (x *buildActionGenerator) LinkActions(unit *Unit, pchs ActionSet, objs ActionSet) (ActionSet, error) {
	AssertIn(unit.Payload, PAYLOAD_EXECUTABLE, PAYLOAD_SHAREDLIB)

	compileDeps, err := x.GetOutputActions(unit.CompileDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	linkDeps, err := x.GetOutputActions(unit.LinkDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	runtimeDeps, err := x.GetOutputActions(unit.RuntimeDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	compiler, err := unit.GetBuildCompiler()
	if err != nil {
		return ActionSet{}, err
	}

	dependencies := ActionSet{}
	dependencies.Append(pchs...)
	dependencies.Append(objs...)
	dependencies.Append(compileDeps...)
	dependencies.Append(linkDeps...)

	inputs := dependencies.GetExportFiles()
	outputs := FileSet{unit.OutputFile}
	exports := FileSet{unit.ExportFile}
	extras := NewFileSet(unit.ExtraFiles...)
	if unit.SymbolsFile.Valid() {
		extras.Append(unit.SymbolsFile)
	}

	compilerRules := compiler.GetCompiler()
	link, err := x.NewAction(
		unit,
		unit.Payload,
		compiler.AllowCaching(unit, unit.Payload),
		compilerRules.Linker,
		UFS.Root,
		compilerRules.Environment,
		inputs, outputs, exports, extras,
		append(dependencies, runtimeDeps...),
		unit.LinkerOptions...)

	return ActionSet{link}, err
}

/***************************************
 * Action Set
 ***************************************/

type ActionSet []Action

func (x ActionSet) Aliases() BuildAliases {
	return MakeBuildAliases(x...)
}
func (x ActionSet) Contains(action Action) bool {
	for _, it := range x {
		if it == action {
			return true
		}
	}
	return false
}
func (x *ActionSet) Append(actions ...Action) {
	Assert(func() bool {
		for _, it := range actions {
			action := it.GetAction()
			AssertMessage(func() bool { return len(action.Inputs) > 0 }, "%v: action without input", action.Alias())
			AssertMessage(func() bool { return len(action.Outputs) > 0 }, "%v: action without output", action.Alias())
		}
		return true
	})

	*x = AppendSlice_CheckUniq(*x, actions, func(x, y Action) bool {
		return x == y
	})
}
func (x *ActionSet) DependsOn(actions ...Action) {
	if len(actions) == 0 {
		return
	}
	for _, action := range *x {
		action.DependsOn(actions...)
	}
}
func (x ActionSet) ExpandDependencies(result *ActionSet) error {
	for _, action := range x {
		if !result.Contains(action) {
			if actions, err := GetBuildActions(action.GetAction().Dependencies...); err == nil {
				if err := actions.ExpandDependencies(result); err == nil {
					result.Append(action)
				} else {
					return err
				}
			} else {
				return err
			}
		}
	}
	return nil
}
func (x ActionSet) GetOutputFiles() (result FileSet) {
	for _, action := range x {
		result.Append(action.GetAction().Outputs...)
	}
	return result
}
func (x ActionSet) GetExportFiles() (result FileSet) {
	for _, action := range x {
		result.Append(action.GetAction().Exports...)
	}
	return result
}

/***************************************
 * Command-line quoting and parameter expansion
 ***************************************/

func performArgumentSubstitution(unit *Unit, payload PayloadType, inputs FileSet, outputs FileSet, arguments ...string) StringSet {
	result := make(StringSet, 0, len(arguments))

	for _, arg := range arguments {
		// substitution rules are inherited from FASTBuild, see https://fastbuild.org/docs/functions/objectlist.html
		if strings.Contains(arg, "%") {
			if payload.HasMultipleInput() {
				if strings.Contains(arg, "%1") {
					for _, input := range inputs {
						relativePath := MakeLocalFilename(input)
						result.Append(strings.ReplaceAll(arg, "%1", relativePath))
					}
					continue
				}
			} else {
				for _, input := range inputs {
					relativePath := MakeLocalFilename(input)
					arg = strings.Replace(arg, "%1", relativePath, 1)
				}
			}

			if payload != PAYLOAD_PRECOMPILEDHEADER {
				for _, output := range outputs {
					relativePath := MakeLocalFilename(output)
					arg = strings.Replace(arg, "%2", relativePath, 1)
				}
			} else { // special for PCH generation
				arg = strings.ReplaceAll(arg, "%2", MakeLocalFilename(unit.PrecompiledObject)) // stdafx.pch
				arg = strings.ReplaceAll(arg, "%3", MakeLocalFilename(outputs[0]))             // stdafx.pch.obj
			}
		}

		result.Append(arg)
	}
	return result
}

func sanitizeArgumentsForAction(arguments ...string) (result StringSet) {
	result = make(StringSet, 0, len(arguments)+8 /* reserve for split args */)

	for _, input := range arguments {
		n := len(input)
		firstIndex := n
		quoteBalance := 0
		concatNextWord := false

		sb := TransientBuffer.Allocate()
		defer TransientBuffer.Release(sb)

		for i, ch := range input {
			commitWord := false
			shouldConcatNextWord := true

			switch ch {
			case '\t', '\r', '\n', ' ':
				if quoteBalance == 0 {
					concatNextWord = false
					if firstIndex < n {
						commitWord = true
						shouldConcatNextWord = false
					}
				}
			case '"':
				if quoteBalance > 0 {
					if quoteBalance -= 1; quoteBalance == 0 {
						commitWord = true
					}
				} else {
					if firstIndex < n {
						commitWord = true
					}
					quoteBalance = 1
				}
			default:
				if firstIndex >= n {
					firstIndex = i
				}
			}

			if commitWord {
				if !concatNextWord {
					if sb.Len() > 0 {
						result = append(result, sb.String())
						sb.Reset()
					}
				}

				sb.WriteString(input[firstIndex:i])

				firstIndex = n
				concatNextWord = shouldConcatNextWord
			}
		}

		if firstIndex < n {
			if !concatNextWord {
				if sb.Len() > 0 {
					result = append(result, sb.String())
					sb.Reset()
				}
			}

			sb.WriteString(input[firstIndex:n])
		}

		if sb.Len() > 0 {
			result = append(result, sb.String())
		}
	}

	return result
}
