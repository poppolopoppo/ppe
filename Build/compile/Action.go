package compile

import (
	. "build/utils"
	"fmt"
	"strings"
)

/***************************************
 * ActionFlags
 ***************************************/

type ActionFlags struct {
	ShowCmds   BoolVar
	ShowOutput BoolVar
}

func (x *ActionFlags) Flags(cfv CommandFlagsVisitor) {
	cfv.Variable("ShowCmds", "print executed compilation commands", &x.ShowCmds)
	cfv.Variable("ShowOutput", "always show compilation commands output", &x.ShowOutput)
}

var GetActionFlags = NewCommandParsableFlags(&ActionFlags{
	ShowCmds: INHERITABLE_FALSE,
})

/***************************************
 * Action
 ***************************************/

type Action interface {
	GetAction() *ActionRules
	DependsOn(actions ...Action)
	Buildable
	fmt.Stringer
}

type ActionRules struct {
	Target       TargetAlias
	Payload      PayloadType
	Executable   Filename
	WorkingDir   Directory
	Environment  ProcessEnvironment
	Inputs       FileSet
	Outputs      FileSet
	Exports      FileSet
	Extras       FileSet
	Arguments    StringSet
	Dependencies BuildAliases
}

func (x *ActionRules) Alias() BuildAlias {
	return MakeBuildAlias("Action", x.Outputs.Join(";"))
}
func (x *ActionRules) Build(bc BuildContext) error {
	// inputs are dynamic dependencies, since they can be generated by another action
	if err := bc.NeedFile(x.Inputs...); err != nil {
		return err
	}

	// limit number of concurrent external processes with MakeGlobalWorkerFuture()
	future := MakeGlobalWorkerFuture(func() (int, error) {
		flags := GetActionFlags()

		if flags.ShowCmds.Get() {
			LogForwardf("%q %v", x.Executable, MakeStringer(func() string {
				return fmt.Sprint("\"", strings.Join(x.Arguments, "\" \""), "\"")
			}))
		}

		err := RunProcess(x.Executable, x.Arguments,
			OptionProcessEnvironment(x.Environment),
			OptionProcessWorkingDir(x.WorkingDir),
			OptionProcessCaptureOutputIf(flags.ShowOutput.Get()),
			OptionProcessNoSpinner)
		return 0, err
	})

	if err := future.Join().Failure(); err != nil {
		return err
	}

	// check that process did write expected files and track them as outputs
	outputFiles := FileSet{}
	outputFiles.AppendUniq(x.Outputs...) // some entries could be shared between the 3 sets
	outputFiles.AppendUniq(x.Exports...)
	outputFiles.AppendUniq(x.Extras...)

	bc.OutputFile(outputFiles...)
	return nil
}

func (x *ActionRules) GetAction() *ActionRules { return x }
func (x *ActionRules) DependsOn(actions ...Action) {
	for _, other := range actions {
		x.Dependencies.AppendUniq(other.Alias())
	}
}

func (x *ActionRules) Serialize(ar Archive) {
	ar.Serializable(&x.Target)
	ar.Serializable(&x.Payload)
	ar.Serializable(&x.Executable)
	ar.Serializable(&x.WorkingDir)
	ar.Serializable(&x.Environment)
	ar.Serializable(&x.Inputs)
	ar.Serializable(&x.Outputs)
	ar.Serializable(&x.Exports)
	ar.Serializable(&x.Extras)
	ar.Serializable(&x.Arguments)
	SerializeSlice(ar, x.Dependencies.Ref())
}
func (x *ActionRules) String() string {
	oss := strings.Builder{}
	fmt.Fprintf(&oss, "%q", x.Executable)
	for _, arg := range x.Arguments {
		fmt.Fprintf(&oss, " %q", arg)
	}
	return oss.String()
}

func makeActionFactory(compiler CompilerAlias, action Action) BuildFactoryTyped[Action] {
	return func(bi BuildInitializer) (Action, error) {
		rules := action.GetAction()

		// track compiler
		if err := bi.DependsOn(compiler.Alias()); err != nil {
			return nil, err
		}

		// track dependent actions as build dependency and as a member alias list
		if err := bi.DependsOn(rules.Dependencies...); err != nil {
			return nil, err
		}

		// do NOT insert inputs as static dependencies here, this is handled by callee

		// add dependent actions to create output directories
		outputDirs := DirSet{}
		for _, filename := range rules.Outputs {
			outputDirs.AppendUniq(filename.Dirname)
		}
		for _, filename := range rules.Extras {
			outputDirs.AppendUniq(filename.Dirname)
		}

		for _, directory := range outputDirs {
			if _, err := BuildDirectoryCreator(directory).Need(bi); err != nil {
				return nil, err
			}
		}

		return action, nil
	}
}

/***************************************
 * Target Actions
 ***************************************/

type PayloadBuildAliases = [NumPayloadTypes]BuildAliases

type TargetActions struct {
	TargetAlias
	OutputType PayloadType
	Payloads   PayloadBuildAliases
}

func (x *TargetActions) Alias() BuildAlias {
	return MakeBuildAlias("Targets", x.TargetAlias.String())
}
func (x *TargetActions) Build(bc BuildContext) error {
	x.OutputType = PAYLOAD_HEADERS
	x.Payloads = PayloadBuildAliases{}

	unit, err := GetBuildUnit(x.TargetAlias)
	if err != nil {
		return err
	}
	Assert(func() bool { return nil != unit })

	generator := buildActionGenerator{
		Environment:   x.TargetAlias.EnvironmentAlias,
		TargetActions: x,
		BuildContext:  bc,
	}

	if err := generator.CreateActions(unit); err != nil {
		return err
	}

	return nil
}
func (x *TargetActions) Serialize(ar Archive) {
	ar.Serializable(&x.TargetAlias)
	ar.Serializable(&x.OutputType)
	for i := range x.Payloads {
		SerializeSlice(ar, x.Payloads[i].Ref())
	}
}

func (x *TargetActions) GetOutputAliases() BuildAliases {
	return x.Payloads[x.OutputType]
}
func (x *TargetActions) GetOutputActions() (ActionSet, error) {
	return GetBuildActions(x.GetOutputAliases()...)
}

func GetBuildActions(aliases ...BuildAlias) (ActionSet, error) {
	result := make(ActionSet, len(aliases))
	for i, alias := range aliases {
		if action, err := FindGlobalBuildable[Action](alias); err == nil {
			Assert(func() bool { return nil != action })
			result[i] = action
		} else {
			return ActionSet{}, err
		}
	}
	return result, nil
}

func GetTargetActions(target TargetAlias) BuildFactoryTyped[*TargetActions] {
	return func(bi BuildInitializer) (*TargetActions, error) {
		if err := bi.NeedBuildable(target); err != nil {
			return nil, err
		}
		return &TargetActions{TargetAlias: target}, nil
	}
}

func ForeachTargetActions(ea EnvironmentAlias, each func(BuildFactoryTyped[*TargetActions]) error, ma ...ModuleAlias) error {
	for _, it := range ma {
		if err := each(GetTargetActions(TargetAlias{EnvironmentAlias: ea, ModuleAlias: it})); err != nil {
			return err
		}
	}
	return nil
}

/***************************************
 * Build Action Generator
 ***************************************/

type buildActionGenerator struct {
	Environment EnvironmentAlias
	*TargetActions
	BuildContext
}

func (x *buildActionGenerator) CreateActions(unit *Unit) error {
	var targetOutputs ActionSet
	x.OutputType = unit.Payload

	customs, err := x.CustomActions(unit, ActionSet{})
	if err != nil {
		return err
	}

	if unit.Payload != PAYLOAD_HEADERS {
		pchs, err := x.PrecompilerHeaderActions(unit, customs)
		if err != nil {
			return err
		}

		x.Payloads[PAYLOAD_PRECOMPILEDHEADER] = pchs.Aliases()

		objs, err := x.ObjectListActions(unit, append(customs, pchs...))
		if err != nil {
			return err
		}

		x.Payloads[PAYLOAD_OBJECTLIST] = objs.Aliases()

		switch unit.Payload {
		case PAYLOAD_EXECUTABLE, PAYLOAD_SHAREDLIB:
			link, err := x.LinkActions(unit, pchs, objs)
			if err != nil {
				return err
			}

			runtimes, err := x.GetOutputActions(unit.RuntimeDependencies...)
			if err != nil {
				return err
			}

			link.DependsOn(runtimes...)

			x.Payloads[unit.Payload] = link.Aliases()
			targetOutputs = link

		case PAYLOAD_STATICLIB:
			lib, err := x.LibrarianActions(unit, pchs, objs)
			if err != nil {
				return err
			}

			x.Payloads[PAYLOAD_STATICLIB] = lib.Aliases()
			targetOutputs = lib

		case PAYLOAD_OBJECTLIST:
			targetOutputs = objs

		default:
			UnexpectedValuePanic(unit.Payload, unit.Payload)
		}

	} else {
		x.Payloads[PAYLOAD_HEADERS] = customs.Aliases()
		targetOutputs = customs
	}

	Assert(func() bool { return x.OutputType == PAYLOAD_HEADERS || len(targetOutputs) > 0 })
	LogVeryVerbose("action: %q outputs %v payload with %d artifacts%s", unit, unit.Payload, len(targetOutputs),
		MakeStringer(func() string {
			if IsLogLevelActive(LOG_VERYVERBOSE) {
				allActions := ActionSet{}
				if err := targetOutputs.ExpandDependencies(&allActions); err == nil {
					return fmt.Sprintf("(%d total actions)", len(allActions))
				} else {
					return fmt.Sprint(err)
				}
			}
			return ""
		}))

	return nil
}

func (x *buildActionGenerator) NewActionRules(
	unit *Unit,
	payload PayloadType,
	executable Filename,
	workingDir Directory,
	environment ProcessEnvironment,
	inputs, outputs, exports, extras FileSet,
	dependentActions ActionSet,
	arguments ...string) *ActionRules {
	Assert(func() bool { return len(inputs) > 0 })
	Assert(func() bool { return len(outputs) > 0 })

	// perform argument expansion now
	arguments = performArgumentSubstitution(unit, payload, inputs, outputs, arguments...)

	return &ActionRules{
		Target:       unit.Target,
		Payload:      payload,
		Executable:   executable,
		WorkingDir:   workingDir,
		Environment:  environment,
		Inputs:       inputs,
		Outputs:      outputs,
		Exports:      exports,
		Extras:       extras,
		Arguments:    sanitizeArgumentsForAction(arguments...),
		Dependencies: dependentActions.Aliases(),
	}
}

func (x *buildActionGenerator) NewAction(
	unit *Unit,
	payload PayloadType,
	executable Filename,
	workingDir Directory,
	environment ProcessEnvironment,
	inputs, outputs, exports, extras FileSet,
	dependentActions ActionSet,
	arguments ...string) Action {
	rules := x.NewActionRules(
		unit, payload, executable, workingDir, environment,
		inputs, outputs, exports, extras, dependentActions, arguments...,
	)
	x.BuildContext.OutputNode(makeActionFactory(unit.CompilerAlias, rules))
	return rules
}
func (x *buildActionGenerator) NewSourceDependencyAction(
	compiler Compiler,
	unit *Unit,
	payload PayloadType,
	executable Filename,
	workingDir Directory,
	environment ProcessEnvironment,
	inputs, outputs, exports, extras FileSet,
	dependentActions ActionSet,
	arguments ...string) Action {
	rules := x.NewActionRules(
		unit, payload, executable, workingDir, environment,
		inputs, outputs, exports, extras, dependentActions, arguments...,
	)
	action := compiler.SourceDependencies(rules)
	x.BuildContext.OutputNode(makeActionFactory(compiler.GetCompiler().CompilerAlias, action))
	return action
}

func (x *buildActionGenerator) ForEachTargetActions(each func(*TargetActions) error, targets ...TargetAlias) error {
	for _, it := range targets {
		if target, err := GetTargetActions(it).Need(x.BuildContext); err == nil {
			if err := each(target); err != nil {
				return err
			}
		} else {
			return err
		}
	}
	return nil
}
func (x *buildActionGenerator) GetOutputActions(targets ...TargetAlias) (ActionSet, error) {
	result := ActionSet{}
	err := x.ForEachTargetActions(func(ta *TargetActions) error {
		if actions, err := ta.GetOutputActions(); err == nil {
			result = append(result, actions...)
		} else {
			return err
		}
		return nil
	}, targets...)
	return result, err
}

func (x *buildActionGenerator) PrecompilerHeaderActions(unit *Unit, dependencies ActionSet) (ActionSet, error) {
	actions := ActionSet{}
	switch unit.PCH {
	case PCH_DISABLED:
		// nothing to do
	case PCH_MONOLITHIC:
		compiler, err := unit.GetBuildCompiler()
		if err != nil {
			return ActionSet{}, err
		}
		compilerRules := compiler.GetCompiler()
		pchObject := Filename{
			Dirname:  unit.PrecompiledObject.Dirname,
			Basename: unit.PrecompiledObject.Basename + compiler.Extname(PAYLOAD_OBJECTLIST)}
		actions.Append(x.NewSourceDependencyAction(
			compiler,
			unit,
			PAYLOAD_PRECOMPILEDHEADER,
			compilerRules.Executable,
			UFS.Root,
			compilerRules.Environment,
			FileSet{unit.PrecompiledSource, unit.PrecompiledHeader},
			FileSet{pchObject},
			FileSet{pchObject},
			FileSet{unit.PrecompiledObject},
			dependencies,
			unit.PrecompiledHeaderOptions...))
	case PCH_SHARED:
		return ActionSet{}, fmt.Errorf("PCH_SHARED is not supported at the monent")
	default:
		UnexpectedValuePanic(unit.PCH, unit.PCH)
	}
	return actions, nil
}
func (x *buildActionGenerator) CustomActions(unit *Unit, dependencies ActionSet) (ActionSet, error) {
	result := ActionSet{}
	for _, custom := range unit.CustomUnits {
		if actions, err := x.ObjectListActions(&custom.Unit, dependencies); err == nil {
			result.Append(actions...)
		} else {
			return ActionSet{}, err
		}
	}
	return result, nil
}
func (x *buildActionGenerator) ObjectAction(
	unit *Unit, dependencies ActionSet,
	compiler Compiler,
	input, output Filename) Action {
	compilerRules := compiler.GetCompiler()
	return x.NewSourceDependencyAction(
		compiler,
		unit,
		PAYLOAD_OBJECTLIST,
		compilerRules.Executable,
		UFS.Root,
		compilerRules.Environment,
		FileSet{input}, FileSet{output}, FileSet{output}, FileSet{},
		dependencies,
		unit.CompilerOptions...)
}
func (x *buildActionGenerator) ObjectListActions(unit *Unit, dependencies ActionSet) (ActionSet, error) {
	includeDeps, err := x.GetOutputActions(unit.IncludeDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	compiler, err := unit.GetBuildCompiler()
	if err != nil {
		return ActionSet{}, err
	}

	dependencies = append(dependencies, includeDeps...)
	objs := make(ActionSet, len(unit.SourceFiles))

	for i, input := range unit.SourceFiles {
		output := unit.GetPayloadOutput(compiler, input, PAYLOAD_OBJECTLIST)
		objs[i] = x.ObjectAction(unit, dependencies, compiler, input, output)
	}

	return objs, nil
}
func (x *buildActionGenerator) LibrarianActions(unit *Unit, pchs ActionSet, objs ActionSet) (ActionSet, error) {
	AssertIn(unit.Payload, PAYLOAD_STATICLIB, PAYLOAD_SHAREDLIB)

	compileDeps, err := x.GetOutputActions(unit.CompileDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	compiler, err := unit.GetBuildCompiler()
	if err != nil {
		return ActionSet{}, err
	}

	compilerRules := compiler.GetCompiler()
	dependencies := ActionSet{}
	dependencies.Append(pchs...)
	dependencies.Append(objs...)
	dependencies.Append(compileDeps...)

	inputs := dependencies.GetExportFiles()
	outputs := FileSet{unit.OutputFile}
	exports := FileSet{unit.ExportFile}
	extras := NewFileSet(unit.ExtraFiles...)
	if unit.SymbolsFile.Valid() {
		extras.Append(unit.SymbolsFile)
	}

	lib := x.NewAction(
		unit,
		PAYLOAD_STATICLIB,
		compilerRules.Librarian,
		UFS.Root,
		compilerRules.Environment,
		inputs, outputs, exports, extras,
		dependencies,
		unit.LibrarianOptions...)

	return ActionSet{lib}, nil
}
func (x *buildActionGenerator) LinkActions(unit *Unit, pchs ActionSet, objs ActionSet) (ActionSet, error) {
	AssertIn(unit.Payload, PAYLOAD_EXECUTABLE, PAYLOAD_SHAREDLIB)

	compileDeps, err := x.GetOutputActions(unit.CompileDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	linkDeps, err := x.GetOutputActions(unit.LinkDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	runtimeDeps, err := x.GetOutputActions(unit.RuntimeDependencies...)
	if err != nil {
		return ActionSet{}, err
	}

	compiler, err := unit.GetBuildCompiler()
	if err != nil {
		return ActionSet{}, err
	}

	dependencies := ActionSet{}
	dependencies.Append(pchs...)
	dependencies.Append(objs...)
	dependencies.Append(compileDeps...)
	dependencies.Append(linkDeps...)

	inputs := dependencies.GetExportFiles()
	outputs := FileSet{unit.OutputFile}
	exports := FileSet{unit.ExportFile}
	extras := NewFileSet(unit.ExtraFiles...)
	if unit.SymbolsFile.Valid() {
		extras.Append(unit.SymbolsFile)
	}

	compilerRules := compiler.GetCompiler()
	link := x.NewAction(
		unit,
		unit.Payload,
		compilerRules.Linker,
		UFS.Root,
		compilerRules.Environment,
		inputs, outputs, exports, extras,
		append(dependencies, runtimeDeps...),
		unit.LinkerOptions...)

	return ActionSet{link}, nil
}

/***************************************
 * Action Set
 ***************************************/

type ActionSet []Action

func (x ActionSet) Aliases() BuildAliases {
	return MakeBuildAliases(x...)
}
func (x ActionSet) Contains(action Action) bool {
	for _, it := range x {
		if it == action {
			return true
		}
	}
	return false
}
func (x *ActionSet) Append(actions ...Action) {
	*x = AppendSlice_CheckUniq(*x, actions, func(x, y Action) bool {
		return x == y
	})
}
func (x *ActionSet) DependsOn(actions ...Action) {
	if len(actions) == 0 {
		return
	}
	for _, action := range *x {
		action.DependsOn(actions...)
	}
}
func (x ActionSet) ExpandDependencies(result *ActionSet) error {
	for _, action := range x {
		if !result.Contains(action) {
			if actions, err := GetBuildActions(action.GetAction().Dependencies...); err == nil {
				if err := actions.ExpandDependencies(result); err == nil {
					result.Append(action)
				} else {
					return err
				}
			} else {
				return err
			}
		}
	}
	return nil
}
func (x ActionSet) GetOutputFiles() (result FileSet) {
	for _, action := range x {
		result.Append(action.GetAction().Outputs...)
	}
	return result
}
func (x ActionSet) GetExportFiles() (result FileSet) {
	for _, action := range x {
		result.Append(action.GetAction().Exports...)
	}
	return result
}

/***************************************
 * Command-line quoting and parameter expansion
 ***************************************/

func performArgumentSubstitution(unit *Unit, payload PayloadType, inputs FileSet, outputs FileSet, arguments ...string) StringSet {
	result := make(StringSet, 0, len(arguments))

	for _, arg := range arguments {
		// substitution rules are inherited from FASTBuild, see https://fastbuild.org/docs/functions/objectlist.html
		if strings.Contains(arg, "%") {
			if payload.HasMultipleInput() {
				if strings.Contains(arg, "%1") {
					for _, input := range inputs {
						relativePath := MakeLocalFilename(input)
						result.Append(strings.ReplaceAll(arg, "%1", relativePath))
					}
					continue
				}
			} else {
				for _, input := range inputs {
					relativePath := MakeLocalFilename(input)
					arg = strings.Replace(arg, "%1", relativePath, 1)
				}
			}

			if payload != PAYLOAD_PRECOMPILEDHEADER {
				for _, output := range outputs {
					relativePath := MakeLocalFilename(output)
					arg = strings.Replace(arg, "%2", relativePath, 1)
				}
			} else { // special for PCH generation
				arg = strings.ReplaceAll(arg, "%2", MakeLocalFilename(unit.PrecompiledObject)) // stdafx.pch
				arg = strings.ReplaceAll(arg, "%3", MakeLocalFilename(outputs[0]))             // stdafx.pch.obj
			}
		}

		result.Append(arg)
	}
	return result
}

func sanitizeArgumentsForAction(arguments ...string) (result StringSet) {
	result = make(StringSet, 0, len(arguments)+8 /* reserve for split args */)

	for _, input := range arguments {
		n := len(input)
		firstIndex := n
		quoteBalance := 0
		concatNextWord := false

		for i, ch := range input {
			commitWord := false
			shouldConcatNextWord := true

			switch ch {
			case '\t', '\r', '\n', ' ':
				if quoteBalance == 0 {
					concatNextWord = false
					if firstIndex < n {
						commitWord = true
						shouldConcatNextWord = false
					}
				}
			case '"':
				if quoteBalance > 0 {
					if quoteBalance -= 1; quoteBalance == 0 {
						commitWord = true
					}
				} else {
					if firstIndex < n {
						commitWord = true
					}
					quoteBalance = 1
				}
			default:
				if firstIndex >= n {
					firstIndex = i
				}
			}

			if commitWord {
				if w := input[firstIndex:i]; concatNextWord && len(result) > 0 {
					result[len(result)-1] += w
				} else {
					result = append(result, w)
				}

				firstIndex = n
				concatNextWord = shouldConcatNextWord
			}
		}

		if firstIndex < n {
			if w := input[firstIndex:n]; concatNextWord && len(result) > 0 {
				result[len(result)-1] += w
			} else {
				result = append(result, w)
			}
		}
	}

	return result
}
