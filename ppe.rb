#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'Build/Build.rb'

class Build::Namespace
    include Build
    def ppe_headers!(name, &cfg)
        self.headers!(name) do
            glob!(path: nil)
            includePath!($SourcePath, File.join($SourcePath, 'Runtime', 'Core', 'Public'))
            instance_exec(&cfg) if cfg
        end
    end
    def ppe_external!(name, &cfg)
        self.external!(name) do
            tag!(:nopdb, :nounity)
            glob!(path: nil)
            includePath!(File.join($SourcePath, 'Runtime', 'Core', 'Public'))
            Namespace.ppe_common(self, &cfg)
        end
    end
    def ppe_module!(name, &cfg)
        self.library!(name) do
            glob!(path: 'Private')
            pch!('stdafx.h', 'stdafx.cpp')
            #source_files!('ModuleExport.cpp')
            #force_includes!(File.join(abs_path, 'Public', "#{name}Module.h"))
            Namespace.ppe_common(self, &cfg)
        end
    end
    def ppe_executable!(name, usage, &cfg)
        self.executable!(name) do
            tag!(:nounity)
            glob!(path: 'Private')
            pch!('stdafx.h', 'stdafx.cpp')
            define!("PPE_TARGET_NAME=#{abs_path}")
            case usage
            when :Runtime,:Shipping,:Tools,:Developer
                define!("PPE_TARGET_USAGE=#{usage}")
            else
                Assert.unexpected(usage)
            end
            if Build.os_windows?
                ## natvis integration
                linkerOptions << "/NATVIS:\"#{File.join($ExtrasPath, 'Debug', 'PPE.natvis')}\""
                ## resource compiler
                rel_resource_rc = 'resource.rc'
                abs_resource_rc = File.join($SourcePath, expand_path(rel_resource_rc))
                unit!('Resource') do
                    Log.verbose('add resource rc unit to <%s> for "%s"', abs_path, abs_resource_rc)
                    compiler_override!(Build.WindowsResourceCompiler)
                    source_files!(rel_resource_rc)
                end if File.exist?(abs_resource_rc)
            end
            Namespace.ppe_common(self, &cfg)
        end
    end
private
    def self.ppe_common(target, &cfg)
        target.define!("EXPORT_PPE_#{target.var_path.upcase}")
        target.includePath!($SourcePath)
        target.instance_exec(&cfg) if cfg
        return Namespace.ppe_generated(target)
    end
    def self.ppe_generated(target)
        target.generate!('BuildVersion.generated.h') do |facet, env, io|
            io.puts! "// Build version generated by #{Build::Script} v#{Build::VERSION}"
            io.puts! "namespace Generated {"
            io.scope! do
                puts! "constexpr const char BuildBranch[]   = \"#{Build.branch?}\";"
                puts! "constexpr const char BuildRevision[] = \"#{Build.revision?}\";"
                puts! "constexpr const i64  BuildTimestamp  = #{Build.timestamp?};"
            end
            io.puts! "} //!namespace Generated"
        end
        target.generate!('BuildModules.generated.h') do |facet, env, io|
            io.puts! "// Build version generated by #{Build::Script} v#{Build::VERSION}"
            io.puts! '#include "Modular/ModuleRegistration.h"'

            modules = []
            target.all_dependencies do |(dep, visibility)|
                next if visibility == :runtime
                next unless dep.library?
                modules << dep
            end

            modules.each do |dep|
                io.puts! "#include \"#{dep.name}Module.h\""
            end

            io.puts! "namespace Generated {"
            io.indent!

            io.puts! "inline void Build_RegisterStaticModules() NOEXCEPT {"
            io.scope! do
                puts! "using namespace ::PPE;"
                puts! "auto& registry = ModuleStaticRegistry();"
                modules.each do |dep|
                    puts! "registry.RegisterModule(F#{dep.name}Module::StaticInfo);"
                end
            end
            io.puts! "}"
            io.puts! "inline void Build_UnregisterStaticModules() NOEXCEPT {"
            io.scope! do
                puts! "using namespace ::PPE;"
                puts! "auto& registry = ModuleStaticRegistry();"
                modules.reverse_each do |dep|
                    puts! "registry.UnregisterModule(F#{dep.name}Module::StaticInfo);"
                end
            end
            io.puts! "}"

            io.unindent!
            io.puts! "} //!namespace Generated"
        end
        return target
    end
end

require_relative 'Source/Source.rb'

Build.main() do
    Build.PPE
end
