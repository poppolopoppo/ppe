#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'Build/Build.rb'

require 'pathname'

class Build::Namespace
    include Build
    def ppe_headers!(name, &cfg)
        self.headers!(name) do
            glob!(path: nil)
            includePath!($SourcePath, File.join($SourcePath, 'Runtime', 'Core', 'Public'))
            instance_exec(&cfg) if cfg
        end
    end
    def ppe_external!(name, &cfg)
        self.external!(name) do
            tag!(:nopdb, :nounity)
            glob!(path: nil)
            includePath!(File.join($SourcePath, 'Runtime', 'Core', 'Public'))
            Namespace.ppe_common(self, &cfg)
        end
    end
    def ppe_module!(name, &cfg)
        self.library!(name) do
            glob!(path: 'Private')
            pch!('stdafx.h', 'stdafx.cpp')
            #source_files!('ModuleExport.cpp')
            #force_includes!(File.join(abs_path, 'Public', "#{name}Module.h"))
            Namespace.ppe_common(self, &cfg)
        end
    end
    def ppe_executable!(name, usage, &cfg)
        self.executable!(name) do
            tag!(:nounity)
            glob!(path: 'Private')
            pch!('stdafx.h', 'stdafx.cpp')
            define!("PPE_TARGET_NAME=#{abs_path}")
            case usage
            when :Runtime,:Shipping,:Tools,:Developer
                define!("PPE_TARGET_USAGE=#{usage}")
            else
                Assert.unexpected(usage)
            end
            if Build.os_windows?
                ## natvis integration
                linkerOptions << "/NATVIS:\"#{File.join($ExtrasPath, 'Debug', 'PPE.natvis')}\""
                ## resource compiler
                rel_resource_rc = 'resource.rc'
                abs_resource_rc = File.join($SourcePath, expand_path(rel_resource_rc))
                unit!('Resource') do
                    Log.verbose('add resource rc unit to <%s> for "%s"', abs_path, abs_resource_rc)
                    compiler_override!(Build.WindowsResourceCompiler)
                    source_files!(rel_resource_rc)
                end if File.exist?(abs_resource_rc)
            end
            Namespace.ppe_common(self, &cfg)
        end
    end
private
    def self.ppe_common(target, &cfg)
        target.define!("EXPORT_PPE_#{target.var_path.upcase}")
        target.includePath!($SourcePath)
        target.instance_exec(&cfg) if cfg
        return Namespace.ppe_generated(target)
    end
    def self.ppe_target_module_name(target)
        return "#{target.name}Module"
    end
    def self.ppe_target_module_anchor(target)
        return "PPE_#{target.var_path}_StaticInfo"
    end
    def self.ppe_generated(target)
        target.generate!('BuildVersion.generated.h') do |facet, env, io|
            io.heredoc! %{
#pragma once
// Build version generated by #{Build::Script} v#{Build::VERSION}
#include "Core_fwd.h"
namespace PPE { namespace Generated {
constexpr const char BuildBranch[]   = \"#{Build.branch?}\";
constexpr const char BuildRevision[] = \"#{Build.revision?}\";
constexpr const i64  BuildTimestamp  = #{Build.timestamp?};
} //!namespace Generated
} //!namespace PPE
}
        end
        target.generate!('BuildModules.generated.h') do |facet, env, io|
            static_modules = []
            dynamic_modules = []
            target.all_dependencies do |(dep, visibility)|
                next unless dep.library?
                case visibility
                when :runtime
                    (env.target_dynamic_link?(dep) ? dynamic_modules : static_modules) << dep
                when :public, :private
                    static_modules << dep
                else
                    Assert.unexpected(visibility)
                end
            end

            dependency_list = target.dependency_list

            io.heredoc! %{
#pragma once

// Build modules generated by #{Build::Script} v#{Build::VERSION}
#include "Core_fwd.h"
#include "IO/StringView.h"
#include "Modular/ModuleRegistration.h"

#include <array>
}
            unless target.executable?
                io.heredoc! %{
// DLL exports for current module:
#include \"#{Namespace.ppe_target_module_name(target)}.h\"
extern \"C\" DLL_EXPORT const void* #{Namespace.ppe_target_module_anchor(target)}() {
  return (&::PPE::F#{Namespace.ppe_target_module_name(target)}::StaticInfo);
}
}
            end
            io.heredoc! %{
// DLL imports for current module:
#{static_modules.collect do |dep|
%{#include \"#{dep.name}Module.h\"
} end.join('')}
#{static_modules.collect do |dep|
%{extern \"C\" DLL_IMPORT const void* #{Namespace.ppe_target_module_anchor(dep)}();
} end.join('')}
namespace PPE { namespace Generated {
// register/unregister for static modules:
inline void RegisterStaticModules() NOEXCEPT {
    #{static_modules.empty? ? '//' : ''}auto& registry = FModuleStaticRegistration::Get();
#{static_modules.collect do |dep|
%{    registry.RegisterAnchor(&#{Namespace.ppe_target_module_anchor(dep)});
} end.join('')}
}
inline void UnregisterStaticModules() NOEXCEPT {
    #{static_modules.empty? ? '//' : ''}auto& registry = FModuleStaticRegistration::Get();
#{static_modules.collect do |dep|
%{    registry.UnregisterAnchor(&#{Namespace.ppe_target_module_anchor(dep)});
} end.reverse.join('')}
}
// register/unregister for runtime modules:
inline void RegisterDynamicModules() NOEXCEPT {
    #{dynamic_modules.empty? ? '//' : ''}auto& registry = FModuleDynamicRegistration::Get();
#{dynamic_modules.collect do |dep|
    libpath = env.target_artifact_path(dep)
    libpath = env.relative_path($BinariesPath, libpath)
%{    registry.RegisterLibrary("#{dep.abs_path}", "#{Namespace.ppe_target_module_anchor(dep)}", L"#{libpath}");
}end.join('')}
}
inline void UnregisterDynamicModules() NOEXCEPT {
    #{dynamic_modules.empty? ? '//' : ''}auto& registry = FModuleDynamicRegistration::Get();
#{dynamic_modules.collect do |dep|
%{    registry.UnregisterLibrary("#{dep.abs_path}");
}end.join('')}
}
// list module dependencies by name:
constexpr std::array<FStringView, #{dependency_list.length}> DependencyList {
#{dependency_list.collect do |dep|
%{    MakeStringView("#{dep}"),
}end.join('')}};
} //!namespace Generated
} //!namespace PPE
}
        end
        return target
    end
end

require_relative 'Source/Source.rb'

Build.main() do
    Build.PPE
end
