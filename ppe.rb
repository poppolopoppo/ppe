#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'Build/Build.rb'

class Build::Namespace
    include Build
    def ppe_headers!(name, &cfg)
        self.headers!(name) do
            glob!(path: nil)
            includePath!($SourcePath, File.join($SourcePath, 'Runtime', 'Core', 'Public'))
            instance_exec(&cfg) if cfg
        end
    end
    def ppe_external!(name, &cfg)
        self.external!(name) do
            tag!(:nopdb, :nounity)
            glob!(path: nil)
            includePath!(File.join($SourcePath, 'Runtime', 'Core', 'Public'))
            Namespace.ppe_common(self, &cfg)
        end
    end
    def ppe_module!(name, &cfg)
        self.library!(name) do
            glob!(path: 'Private')
            pch!('stdafx.h', 'stdafx.cpp')
            #source_files!('ModuleExport.cpp')
            #force_includes!(File.join(abs_path, 'Public', "#{name}Module.h"))
            Namespace.ppe_common(self, &cfg)
        end
    end
    def ppe_executable!(name, usage, &cfg)
        self.executable!(name) do
            tag!(:nounity)
            glob!(path: 'Private')
            pch!('stdafx.h', 'stdafx.cpp')
            define!("PPE_TARGET_NAME=#{abs_path}")
            case usage
            when :Runtime,:Shipping,:Tools,:Developer
                define!("PPE_TARGET_USAGE=#{usage}")
            else
                Assert.unexpected(usage)
            end
            if Build.os_windows?
                ## natvis integration
                linkerOptions << "/NATVIS:\"#{File.join($ExtrasPath, 'Debug', 'PPE.natvis')}\""
                ## resource compiler
                rel_resource_rc = 'resource.rc'
                abs_resource_rc = File.join($SourcePath, expand_path(rel_resource_rc))
                unit!('Resource') do
                    Log.verbose('add resource rc unit to <%s> for "%s"', abs_path, abs_resource_rc)
                    compiler_override!(Build.WindowsResourceCompiler)
                    source_files!(rel_resource_rc)
                end if File.exist?(abs_resource_rc)
            end
            Namespace.ppe_common(self, &cfg)
        end
    end
private
    def self.ppe_common(target, &cfg)
        target.define!("EXPORT_PPE_#{target.var_path.upcase}")
        target.includePath!($SourcePath)
        target.instance_exec(&cfg) if cfg
        return Namespace.ppe_generated(target)
    end
    def self.ppe_target_module_name(target)
        return "#{target.name}Module"
    end
    def self.ppe_target_module_anchor(target)
        return "PPE_#{Namespace.ppe_target_module_name(target)}_StaticInfo"
    end
    def self.ppe_generated(target)
        target.generate!('BuildVersion.generated.h') do |facet, env, io|
            io.puts! "// Build version generated by #{Build::Script} v#{Build::VERSION}"
            io.puts! '#include "Core_fwd.h"'
            io.puts! 'namespace Generated {'
            io.scope! do
                puts! "constexpr const char BuildBranch[]   = \"#{Build.branch?}\";"
                puts! "constexpr const char BuildRevision[] = \"#{Build.revision?}\";"
                puts! "constexpr const i64  BuildTimestamp  = #{Build.timestamp?};"
            end
            io.puts! '} //!namespace Generated'
        end
        target.generate!('BuildModules.generated.h') do |facet, env, io|
            io.puts! "// Build version generated by #{Build::Script} v#{Build::VERSION}"
            io.puts! '#include "Core_fwd.h"'
            io.puts! '#include "Modular/ModuleRegistration.h"'

            if target.library?
                io.puts! '// DLL export for current module:'
                io.puts! "#include \"#{Namespace.ppe_target_module_name(target)}.h\""
                io.puts! "extern \"C\" DLL_EXPORT const void* #{Namespace.ppe_target_module_anchor(target)}() {"
                io.puts! "  return (&::PPE::F#{Namespace.ppe_target_module_name(target)}::StaticInfo);"
                io.puts! "}"
            end

            static_modules = []
            runtime_modules = []
            target.all_dependencies do |(dep, visibility)|
                next unless dep.library?
                case visibility
                when :runtime
                    runtime_modules << dep
                when :public, :private
                    static_modules << dep
                else
                    Assert.unexpected(visibility)
                end
            end

            io.puts! '// register/unregister for static modules:'
            static_modules.each do |dep|
                io.puts! "#include \"#{dep.name}Module.h\""
            end
            static_modules.each do |dep|
                io.puts! "extern \"C\" DLL_IMPORT const void* #{Namespace.ppe_target_module_anchor(dep)}();"
            end
            io.puts! "namespace Generated {"
            io.indent!
            io.puts! "inline void RegisterStaticModules() NOEXCEPT {"
            io.scope! do
                puts! "using namespace ::PPE;"
                puts! "auto& registry = FModuleStaticRegistration::Get();"
                static_modules.each do |dep|
                    puts! "registry.RegisterAnchor(&#{Namespace.ppe_target_module_anchor(dep)});"
                end
            end unless static_modules.empty?
            io.puts! "}"
            io.puts! "inline void UnregisterStaticModules() NOEXCEPT {"
            io.scope! do
                puts! "using namespace ::PPE;"
                puts! "auto& registry = FModuleStaticRegistration::Get();"
                static_modules.reverse_each do |dep|
                    puts! "registry.UnregisterAnchor(&#{Namespace.ppe_target_module_anchor(dep)});"
                end
            end unless static_modules.empty?
            io.puts! "}"
            io.unindent!
            io.puts! "} //!namespace Generated"
        end
        return target
    end
end

require_relative 'Source/Source.rb'

Build.main() do
    Build.PPE
end
